This is ed.info, produced by makeinfo version 6.3 from ed.texi.

Copyright (C) 1993-2013 Andrew L. Moore, SlewSys Research



_A Tutorial Introduction to the Unix Text Editor_ and
_Advanced Editing on UNIX_
Copyright (C) Brian W. Kernighan, Lucent Laboratories
Reprinted courtesy of Lucent Laboratories

INFO-DIR-SECTION Text creation and manipulation
START-INFO-DIR-ENTRY
* ed : (ed).The Standard Unix Text Editor
END-INFO-DIR-ENTRY


File: ed.info,  Node: Top,  Next: Overview,  Prev: (dir),  Up: (dir)

The 'Ed' Text Editor
********************

This manual is intended to serve as both tutorial and reference for
'ed', the "standard Unix text editor", version 2.0.2.  Of historical
interest is that 'ed' was the original Unix text editor and introduced
the "regular expression" method of representing text patterns.

* Menu:

* Overview::              Overview of the 'ed' text editor.
* Tutorial::              Tutorial introduction to 'ed'.
* Switches::              Invoking 'ed' from the command line.
* Line Addressing::       Specifying lines in the buffer.
* Regular Expressions::   Patterns for searching text.
* Extended Expressions::  Advanced patterns for searching text.
* Command Reference::     'Ed' Command Reference.
* Environment::           Environment variables affecting 'ed'.
* Limitations::           Internal limits of 'ed'.
* Error Handling::        Error handling, diagnostics and  exit status.


File: ed.info,  Node: Overview,  Next: Tutorial,  Prev: Top,  Up: Top

1 'Ed': Modal, Line-Oriented Text Editor
****************************************

'Ed' is a "modal, line-oriented text editor".

'Ed' is a "text editor", .i.e., a utility for creating, displaying,
modifying and otherwise manipulating text files.  'red' is 'ed'
restricted: only files in the current directory can be edited and shell
access is prohibited.

If invoked with argument FILE, then a copy of FILE is read from disk
into a region of memory called the "editor buffer".  Edits are made to
this buffer and not directly to FILE itself.  Any changes can be saved
by explicitly writing the editor buffer back to disk with a 'w'
("write") command.  Upon quiting 'ed', unsaved changes are lost.

'Ed' is "modal", i.e., editing is done in two distinct modes: "command"
and "input".  When first invoked, 'ed' is in command mode.  In this mode
commands are read from the standard input and executed to manipulate the
contents of the editor buffer.  A typical command might look like:

     ,s/OLD/NEW/g

which replaces all occurrences of the string OLD with NEW.

When an input command, such as 'a' (append), 'i' (insert) or 'c'
(change), is given, 'ed' enters input mode.  In this mode, no commands
are available; instead, 'ed' reads lines of text from the standard input
and places them into the editor buffer.  A "line" consists of text up to
and including a <RET> character.  Input mode is terminated by entering a
single period ('.') on a line.

'Ed' is "line-oriented", i.e., all 'ed' commands operate on whole lines
or ranges of lines; e.g., the 'd' command deletes lines; the 'm' command
moves lines, and so on.  It is possible to modify only a portion of a
line by means of replacement, as in the example above.  However even
here, the 's' command is applied to whole lines at a time.

In general, 'ed' commands consist of zero or more line addresses,
followed by a single character command and possibly additional
parameters; i.e., commands have the structure:

     [ADDRESS [,ADDRESS]]COMMAND[PARAMETERS]

The ADDRESSes indicate the line or range of lines to be affected by the
command.  If fewer addresses are given than the command accepts, then
default addresses are used.


File: ed.info,  Node: Tutorial,  Next: Switches,  Prev: Overview,  Up: Top

2 Introduction to Line Editing
******************************

'Ed' was created in 1969 by Ken Thompson as part of the original Unix
system and is essentially unchanged today.  The pattern matching syntax
which 'ed' introduced, and even some of its command syntax, is now
standard across many applications and programming languages.  Its
consistency and general availabiliy across platforms make 'ed' a natural
springboard to learning the Unix system.  Brian W. Kernighan's original
'ed' tutorials are as relevant today as when they were written circa
1970.  They are reprinted here courtesy of Lucent Laboratories.

* Menu:

* A Tutorial Introduction to the UNIX Text Editor::
* Advanced Editing on UNIX::


File: ed.info,  Node: A Tutorial Introduction to the UNIX Text Editor,  Next: Advanced Editing on UNIX,  Prev: Tutorial,  Up: Tutorial

A Tutorial Introduction to the UNIX Text Editor
***********************************************

by Brian W. Kernighan

Almost all text input on the UNIX operating system is done with the
text-editor 'ed'.  This memorandum is a tutorial guide to help beginners
get started with text editing.

Although it does not cover everything, it does discuss enough for most
users' day-to-day needs.  This includes printing, appending, changing,
deleting, moving and inserting entire lines of text; reading and writing
files; context searching and line addressing; the substitute command;
the global commands; and the use of special characters for advanced
editing.

* Menu:

* Introduction:: The purpose of this tutorial.
* Disclaimer:: What you need to know.
* Getting Started:: Invoking 'ed'.
* Creating Text:: The Append command "a"
* Error Messages:: "?"
* Writing to a file:: The Write command "w"
* Leaving ed:: The Quit command "q"
* Exercise 1:: Create a text file.
* Reading text from a file:: The Edit command "e"
* Inserting text from a file:: The Read command "r"
* Exercise 2:: Open text files.
* Printing the buffer:: The Print command "p"
* Exercise 3:: Display the contents of the buffer.
* The current line:: "Dot" or "."
* Deleting lines:: The Delete command "d"
* Exercise 4:: Open, create, view and write files.
* Modifying text:: The Substitute command "s"
* Exercise 5:: Modify text in the buffer.
* Context searching:: "/.../"
* Exercise 6:: Search for text in the buffer.
* Change and Insert:: The Change and Insert, "c" and "i"
* Exercise 7:: Change and insert text.
* Moving text around:: The Move command "m"
* The global commands:: The global commands "g" and "v"
* Special Characters:: "^", ".", "$", "[", "*", "\"
* Summary:: Summary of Commands and Line Numbers.


File: ed.info,  Node: Introduction,  Next: Disclaimer,  Prev: A Tutorial Introduction to the UNIX Text Editor,  Up: A Tutorial Introduction to the UNIX Text Editor

Introduction
============

'Ed' is a "text editor", that is, an interactive program for creating
and modifying "text", using directions provided by a user at a terminal.
The text is often a document like this one, or a program or perhaps data
for a program.

This introduction is meant to simplify learning 'ed'.  The recommended
way to learn 'ed' is to read this document, simultaneously using 'ed' to
follow the examples, then to read the description in section I of the
_UNIX Programmer's Manual_, all the while experimenting with 'ed'.
(Solicitation of advice from experienced users is also useful.)

Do the exercises!  They cover material not completely discussed in the
actual text.  An appendix summarizes the commands.


File: ed.info,  Node: Disclaimer,  Next: Getting Started,  Prev: Introduction,  Up: A Tutorial Introduction to the UNIX Text Editor

Disclaimer
==========

This is an introduction and a tutorial.  For this reason, no attempt is
made to cover more than a part of the facilities that 'ed' offers
(although this fraction includes the most useful and frequently used
parts).  When you have mastered the Tutorial, try _Advanced Editing on
UNIX_. Also, there is not enough space to explain basic UNIX procedures.
We will assume that you know how to log on to UNIX, and that you have at
least a vague understanding of what a file is.  For more on that, read
_UNIX for Beginners_.

You must also know what character to type as the end-of-line on your
particular terminal.  This character is the 'RETURN' key on most
terminals.  Throughout, we will refer to this character, whatever it is,
as 'RETURN'.


File: ed.info,  Node: Getting Started,  Next: Creating Text,  Prev: Disclaimer,  Up: A Tutorial Introduction to the UNIX Text Editor

Getting Started
===============

We'll assume that you have logged in to your system and it has just
printed the prompt character, usually either a '$' or a '%'.  The
easiest way to get 'ed' is to type

     ed   (followed by a return)

You are now ready to go -- 'ed' is waiting for you to tell it what to
do.


File: ed.info,  Node: Creating Text,  Next: Error Messages,  Prev: Getting Started,  Up: A Tutorial Introduction to the UNIX Text Editor

Creating Text -- the Append command "a"
=======================================

As your first problem, suppose you want to create some text starting
from scratch.  Perhaps you are typing the very first draft of a paper;
clearly it will have to start somewhere, and undergo modifications
later.  This section will show how to get some text in, just to get
started.  Later we'll talk about how to change it.

When 'ed' is first started, it is rather like working with a blank piece
of paper -- there is no text or information present.  This must be
supplied by the person using 'ed'; it is usually done by typing in the
text, or by reading it into 'ed' from a file.  We will start by typing
in some text, and return shortly to how to read files.

First a bit of terminology.  In 'ed' jargon, the text being worked on is
said to be "kept in a buffer."  Think of the buffer as a work space, if
you like, or simply as the information that you are going to be editing.
In effect the buffer is like the piece of paper, on which we will write
things, then change some of them, and finally file the whole thing away
for another day.

The user tells 'ed' what to do to his text by typing instructions called
"commands."  Most commands consist of a single letter, which must be
typed in lower case.  Each command is typed on a separate line.
(Sometimes the command is preceded by information about what line or
lines of text are to be affected -- we will discuss these shortly.)
'Ed' makes no response to most commands -- there is no prompting or
typing of messages like "ready".  (This silence is preferred by
experienced users, but sometimes a hangup for beginners.)

The first command is "append", written as the letter

     a

all by itself.  It means "append (or add) text lines to the buffer, as I
type them in."  Appending is rather like writing fresh material on a
piece of paper.

So to enter lines of text into the buffer, just type an 'a' followed by
a 'RETURN', followed by the lines of text you want, like this:

     a
     Now is the time
     for all good men
     to come to the aid of their party.
     .

The only way to stop appending is to type a line that contains only a
period.  The "."  is used to tell 'ed' that you have finished appending.
(Even experienced users forget that terminating "."  sometimes.  If 'ed'
seems to be ignoring you, type an extra line with just "."  on it.  You
may then find you've added some garbage lines to your text, which you'll
have to take out later.)

After the append command has been done, the buffer will contain the
three lines

     Now is the time
     for all good men
     to come to the aid of their party.

The "a" and "."  aren't there, because they are not text.

To add more text to what you already have, just issue another 'a'
command, and continue typing.


File: ed.info,  Node: Error Messages,  Next: Writing to a file,  Prev: Creating Text,  Up: A Tutorial Introduction to the UNIX Text Editor

Error Messages -- "?"
=====================

If at any time you make an error in the commands you type to 'ed', it
will tell you by typing

     ?

This is about as cryptic as it can be, but with practice, you can
usually figure out how you goofed.


File: ed.info,  Node: Writing to a file,  Next: Leaving ed,  Prev: Error Messages,  Up: A Tutorial Introduction to the UNIX Text Editor

Writing text out as a file -- the Write command "w"
===================================================

It's likely that you'll want to save your text for later use.  To write
out the contents of the buffer onto a file, use the "write" command

     w

followed by the filename you want to write on.  This will copy the
buffer's contents onto the specified file (destroying any previous
information on the file).  To save the text on a file named 'junk', for
example, type

     w junk

Leave a space between 'w' and the file name.  'Ed' will respond by
printing the number of characters it wrote out.  In this case, 'ed'
would respond with

     68

(Remember that blanks and the return character at the end of each line
are included in the character count.)  Writing a file just makes a copy
of the text -- the buffer's contents are not disturbed, so you can go on
adding lines to it.  This is an important point.  'Ed' at all times
works on a copy of a file, not the file itself.  No change in the
contents of a file takes place until you give a 'w' command.  (Writing
out the text onto a file from time to time as it is being created is a
good idea, since if the system crashes or if you make some horrible
mistake, you will lose all the text in the buffer but any text that was
written onto a file is relatively safe.)


File: ed.info,  Node: Leaving ed,  Next: Exercise 1,  Prev: Writing to a file,  Up: A Tutorial Introduction to the UNIX Text Editor

Leaving ed -- the Quit command "q"
==================================

To terminate a session with 'ed', save the text you're working on by
writing it onto a file using the 'w' command, and then type the command

     q

which stands for "quit".  The system will respond with the prompt
character ('$' or '%').  At this point your buffer vanishes, with all
its text, which is why you want to write it out before quitting.(1)

   ---------- Footnotes ----------

   (1) Actually, 'ed' will print '?' if you try to quit without writing.
At that point, write if you want; if not, another 'q' will get you out
regardless.


File: ed.info,  Node: Exercise 1,  Next: Reading text from a file,  Prev: Leaving ed,  Up: A Tutorial Introduction to the UNIX Text Editor

Exercise 1:
===========

Enter 'ed' and create some text using

     a
     ... _text_ ...
     .

Write it out using 'w'.  Then leave 'ed' with the 'q' command, and print
the file, to see that everything worked.  (To print a file, say

     pr filename

or

     cat filename

in response to the prompt character.  Try both.)


File: ed.info,  Node: Reading text from a file,  Next: Inserting text from a file,  Prev: Exercise 1,  Up: A Tutorial Introduction to the UNIX Text Editor

Reading text from a file -- the Edit command "e"
================================================

A common way to get text into the buffer is to read it from a file in
the file system.  This is what you do to edit text that you saved with
the 'w' command in a previous session.  The "edit" command 'e' fetches
the entire contents of a file into the buffer.  So if you had saved the
three lines "Now is the time", etc., with a 'w' command in an earlier
session, the 'ed' command

     e junk

would fetch the entire contents of the file junk into the buffer, and
respond

     68

which is the number of characters in junk.  _If anything was already in
the buffer, it is deleted first._

If you use the 'e' command to read a file into the buffer, then you need
not use a file name after a subsequent 'w' command; 'ed' remembers the
last file name used in an 'e' command, and 'w' will write on this file.
Thus a good way to operate is

     ed
     e file
     [editing session]
     w
     q

This way, you can simply say 'w' from time to time, and be secure in the
knowledge that if you got the file name right at the beginning, you are
writing into the proper file each time.

You can find out at any time what file name 'ed' is remembering by
typing the "file" command 'f'.  In this example, if you typed

     f

'ed' would reply

     junk


File: ed.info,  Node: Inserting text from a file,  Next: Exercise 2,  Prev: Reading text from a file,  Up: A Tutorial Introduction to the UNIX Text Editor

Inserting text from a file -- the Read command "r"
==================================================

Sometimes you want to read a file into the buffer without destroying
anything that is already there.  This is done by the "read" command 'r'.
The command

     r junk

will read the file 'junk' into the buffer; it adds it to the end of
whatever is already in the buffer.  So if you do a read after an edit:

     e junk
     r junk

the buffer will contain _two_ copies of the text (six lines).

     Now is the time
     for all good men
     to come to the aid of their party.
     Now is the time
     for all good men
     to come to the aid of their party.

Like the 'w' and 'e' commands, 'r' prints the number of characters read
in, after the reading operation is complete.

Generally speaking, 'r' is much less used than 'e'.


File: ed.info,  Node: Exercise 2,  Next: Printing the buffer,  Prev: Inserting text from a file,  Up: A Tutorial Introduction to the UNIX Text Editor

Exercise 2:
===========

Experiment with the 'e' command -- try reading and printing various
files.  You may get an error '?name', where 'name' is the name of a
file; this means that the file doesn't exist, typically because you
spelled the file name wrong, or perhaps that you are not allowed to read
or write it.  Try alternately reading and appending to see that they
work similarly.  Verify that

     ed filename

is exactly equivalent to

     ed
     e filename

What does

     f filename

do?


File: ed.info,  Node: Printing the buffer,  Next: Exercise 3,  Prev: Exercise 2,  Up: A Tutorial Introduction to the UNIX Text Editor

Printing the contents of the buffer -- the Print command "p"
============================================================

To "print" or list the contents of the buffer (or parts of it) on the
terminal, use the print command

     p

The way this is done is as follows.  Specify the lines where you want
printing to begin and where you want it to end, separated by a comma,
and followed by the letter 'p'.  Thus to print the first two lines of
the buffer, for example, (that is, lines 1 through 2) say

     1,2p (starting line=1, ending line=2 p)

'Ed' will respond with

     Now is the time
     for all good men

Suppose you want to print _all_ the lines in the buffer.  You could use
'1,3p' as above if you knew there were exactly 3 lines in the buffer.
But in general, you don't know how many there are, so what do you use
for the ending line number?  'Ed' provides a shorthand symbol for "line
number of last line in buffer" -- the dollar sign '$'.  Use it this way:

     1,$p

This will print _all_ the lines in the buffer (line 1 to last line.)  If
you want to stop the printing before it is finished, push the 'DEL' or
'Delete' key; 'ed' will type

     ?

and wait for the next command.

To print the _last_ line of the buffer, you could use

     $,$p

but 'ed' lets you abbreviate this to

     $p

You can print any single line by typing the line number followed by a
'p'.  Thus

     1p

produces the response

     Now is the time

which is the first line of the buffer.

In fact, 'ed' lets you abbreviate even further: you can print any single
line by typing _just_ the line number -- no need to type the letter 'p'.
So if you say

     $

'ed' will print the last line of the buffer.

You can also use '$' in combinations like

     $-1,$p

which prints the last two lines of the buffer.  This helps when you want
to see how far you got in typing.


File: ed.info,  Node: Exercise 3,  Next: The current line,  Prev: Printing the buffer,  Up: A Tutorial Introduction to the UNIX Text Editor

Exercise 3:
===========

As before, create some text using the 'a' command and experiment with
the 'p' command.  You will find, for example, that you can't print line
0 or a line beyond the end of the buffer, and that attempts to print a
buffer in reverse order by saying

     3,1p

don't work.


File: ed.info,  Node: The current line,  Next: Deleting lines,  Prev: Exercise 3,  Up: A Tutorial Introduction to the UNIX Text Editor

The current line -- "Dot" or "."
================================

Suppose your buffer still contains the six lines as above, that you have
just typed

     1,3p

and 'ed' has printed the three lines for you.  Try typing just

     p    (no line numbers)

This will print

     to come to the aid of their party.

which is the third line of the buffer.  In fact it is the last (most
recent) line that you have done anything with.  (You just printed it!)
You can repeat this 'p' command without line numbers, and it will
continue to print line 3.

The reason is that 'ed' maintains a record of the last line that you did
anything to (in this case, line 3, which you just printed) so that it
can be used instead of an explicit line number.  This most recent line
is referred to by the shorthand symbol

     .    (pronounced "dot").

Dot is a line number in the same way that '$' is; it means exactly "the
current line", or loosely, "the line you most recently did something
to."  You can use it in several ways -- one possibility is to say

     .,$p

This will print all the lines from (including) the current line to the
end of the buffer.  In our example these are lines 3 through 6.

Some commands change the value of dot, while others do not.  The 'p'
command sets dot to the number of the last line printed; the last
command will set both .  and '$' to 6.

Dot is most useful when used in combinations like this one:

     .+1  (or equivalently, .+1p)

This means "print the next line" and is a handy way to step slowly
through a buffer.  You can also say

     .-1  (or .-1p)

which means "print the line _before_ the current line."  This enables
you to go backwards if you wish.  Another useful one is something like

     .-3,.-1p

which prints the previous three lines.

Don't forget that all of these change the value of dot.  You can find
out what dot is at any time by typing

     .=

'Ed' will respond by printing the value of dot.

Let's summarize some things about the 'p' command and dot.  Essentially
'p' can be preceded by 0, 1, or 2 line numbers.  If there is no line
number given, it prints the "current line", the line that dot refers to.
If there is one line number given (with or without the letter 'p'), it
prints that line (and dot is set there); and if there are two line
numbers, it prints all the lines in that range (and sets dot to the last
line printed.)  If two line numbers are specified the first can't be
bigger than the second (see Exercise 2.)

Typing a single return will cause printing of the next line -- it's
equivalent to .'+1p'.  Try it.  Try typing a '-'; you will find that
it's equivalent to .'-1p'.


File: ed.info,  Node: Deleting lines,  Next: Exercise 4,  Prev: The current line,  Up: A Tutorial Introduction to the UNIX Text Editor

Deleting lines: the "d" command
===============================

Suppose you want to get rid of the three extra lines in the buffer.
This is done by the "delete" command

     d

Except that 'd' deletes lines instead of printing them, its action is
similar to that of 'p'.  The lines to be deleted are specified for 'd'
exactly as they are for 'p':

     _starting line, ending line_ d

Thus the command

     4,$d

deletes lines 4 through the end.  There are now three lines left, as you
can check by using

     1,$p

And notice that '$' now is line 3!  Dot is set to the next line after
the last line deleted, unless the last line deleted is the last line in
the buffer.  In that case, dot is set to '$'.


File: ed.info,  Node: Exercise 4,  Next: Modifying text,  Prev: Deleting lines,  Up: A Tutorial Introduction to the UNIX Text Editor

Exercise 4:
===========

Experiment with 'a', 'e', 'r', 'w', 'p' and 'd' until you are sure that
you know what they do, and until you understand how dot, '$', and line
numbers are used.

If you are adventurous, try using line numbers with 'a', 'r' and 'w' as
well.  You will find that a will append lines _after_ the line number
that you specify (rather than after dot); that 'r' reads a file in
_after_ the line number you specify (not necessarily at the end of the
buffer); and that 'w' will write out exactly the lines you specify, not
necessarily the whole buffer.  These variations are sometimes handy.
For instance you can insert a file at the beginning of a buffer by
saying

     0r filename

and you can enter lines at the beginning of the buffer by saying

     0a
     ... _text_ ...
     .

Notice that .'w' is very different from

     .
     w


File: ed.info,  Node: Modifying text,  Next: Exercise 5,  Prev: Exercise 4,  Up: A Tutorial Introduction to the UNIX Text Editor

Modifying text -- the Substitute command "s"
============================================

We are now ready to try one of the most important of all commands -- the
substitute command

     s

This is the command that is used to change individual words or letters
within a line or group of lines.  It is what you use, for example, for
correcting spelling mistakes and typing errors.

Suppose that by a typing error, line 1 says

     Now is th time

-- the _e_ has been left off _the_.  You can use 's' to fix this up as
follows:

     1s/th/the/

This says: "in line 1, substitute for the characters _th_ the characters
_the_."  To verify that it works ('ed' will not print the result
automatically) say

     p

and get

     Now is the time

which is what you wanted.  Notice that dot must have been set to the
line where the substitution took place, since the 'p' command printed
that line.  Dot is always set this way with the 's' command.

The general way to use the substitute command is

     _starting-line, ending-line_ s/_change this_/_to this_/

Whatever string of characters is between the first pair of slashes is
replaced by whatever is between the second pair, in all the lines
between _starting-line_ and _ending-line_.  Only the first occurrence on
each line is changed, however.  If you want to change _every_
occurrence, see Exercise 5.  The rules for line numbers are the same as
those for 'p', except that dot is set to the last line changed.  (But
there is a trap for the unwary: if no substitution took place, dot is
_not_ changed.  This causes an error '?' as a warning.)

Thus you can say

     1,$s/speling/spelling/

and correct the first spelling mistake on each line in the text.  (This
is useful for people who are consistent misspellers!)

If no line numbers are given, the 's' command assumes we mean "make the
substitution on line dot", so it changes things only on the current
line.  This leads to the very common sequence

     s/_something_/_something else_/p

which makes some correction on the current line, and then prints it, to
make sure it worked out right.  If it didn't, you can try again.
(Notice that there is a 'p' on the same line as the 's' command.  With
few exceptions, 'p' can follow any command; no other multi-command lines
are legal.)

It's also legal to say

     s/...//

which means "change the first string of characters to "_nothing_", i.e.,
remove them.  This is useful for deleting extra words in a line or
removing extra letters from words.  For instance, if you had

     Nowxx is the time

you can say

     s/xx//p

to get

     Now is the time

Notice that '//' (two adjacent slashes) means "no characters", not a
blank.  There _is_ a difference!  (See below for another meaning of
'//'.)


File: ed.info,  Node: Exercise 5,  Next: Context searching,  Prev: Modifying text,  Up: A Tutorial Introduction to the UNIX Text Editor

Exercise 5:
===========

Experiment with the substitute command.  See what happens if you
substitute for some word on a line with several occurrences of that
word.  For example, do this:

     a
     the other side of the coin
     .
     s/the/on the/p

You will get

     on the other side of the coin

A substitute command changes only the first occurrence of the first
string.  You can change all occurrences by adding a 'g' (for "global")
to the 's' command, like this:

     s/.../.../gp

Try other characters instead of slashes to delimit the two sets of
characters in the 's' command -- anything should work except blanks or
tabs.

(If you get funny results using any of the characters

     ^    .    $    [    *    \    &

read the section on "Special Characters".)


File: ed.info,  Node: Context searching,  Next: Exercise 6,  Prev: Exercise 5,  Up: A Tutorial Introduction to the UNIX Text Editor

Context searching -- "/.../"
============================

With the substitute command mastered, you can move on to another highly
important idea of 'ed' -- context searching.

Suppose you have the original three line text in the buffer:

     Now is the time
     for all good men
     to come to the aid of their party.

Suppose you want to find the line that contains _their_ so you can
change it to _the_.  Now with only three lines in the buffer, it's
pretty easy to keep track of what line the word _their_ is on.  But if
the buffer contained several hundred lines, and you'd been making
changes, deleting and rearranging lines, and so on, you would no longer
really know what this line number would be.  Context searching is simply
a method of specifying the desired line, regardless of what its number
is, by specifying some context on it.

The way to say "search for a line that contains this particular string
of characters" is to type

     /_string of characters we want to find_/

For example, the 'ed' command

     /their/

is a context search which is sufficient to find the desired line -- it
will locate the next occurrence of the characters between slashes
("their").  It also sets dot to that line and prints the line for
verification:

     to come to the aid of their party.

"Next occurrence" means that 'ed' starts looking for the string at line
.'+1', searches to the end of the buffer, then continues at line 1 and
searches to line dot.  (That is, the search "wraps around" from '$' to
1.)  It scans all the lines in the buffer until it either finds the
desired line or gets back to dot again.  If the given string of
characters can't be found in any line, 'ed' types the error message

     ?

Otherwise it prints the line it found.

You can do both the search for the desired line _and_ a substitution all
at once, like this:

     /their/s/their/the/p

which will yield

     to come to the aid of the party.

There were three parts to that last command: context search for the
desired line, make the substitution, print the line.

The expression '/their/' is a context search expression.  In their
simplest form, all context search expressions are like this -- a string
of characters surrounded by slashes.  Context searches are
interchangeable with line numbers, so they can be used by themselves to
find and print a desired line, or as line numbers for some other
command, like 's'.  They were used both ways in the examples above.

Suppose the buffer contains the three familiar lines

     Now is the time
     for all good men
     to come to the aid of their party.

Then the 'ed' line numbers

     /Now/+1
     /good/
     /party/-1

are all context search expressions, and they all refer to the same line
(line 2).  To make a change in line 2, you could say

     /Now/+1s/good/bad/

or

     /good/s/good/bad/

or

     /party/-1s/good/bad/

The choice is dictated only by convenience.  You could print all three
lines by, for instance

     /Now/,/party/p

or

     /Now/,/Now/+2p

or by any number of similar combinations.  The first one of these might
be better if you don't know how many lines are involved.  (Of course, if
there were only three lines in the buffer, you'd use

     1,$p

but not if there were several hundred.)

The basic rule is: a context search expression is _the same as_ a line
number, so it can be used wherever a line number is needed.


File: ed.info,  Node: Exercise 6,  Next: Change and Insert,  Prev: Context searching,  Up: A Tutorial Introduction to the UNIX Text Editor

Exercise 6:
===========

Experiment with context searching.  Try a body of text with several
occurrences of the same string of characters, and scan through it using
the same context search.

Try using context searches as line numbers for the substitute, print and
delete commands.  (They can also be used with 'r', 'w', and 'a'.)

Try context searching using '?text?' instead of '/text/'.  This scans
lines in the buffer in reverse order rather than normal.  This is
sometimes useful if you go too far while looking for some string of
characters -- it's an easy way to back up.

(If you get funny results with any of the characters

     ^    .    $    [    *    \    &

read the section on "Special Characters".)

'Ed' provides a shorthand for repeating a context search for the same
string.  For example, the 'ed' line number

     /string/

will find the next occurrence of 'string'.  It often happens that this
is not the desired line, so the search must be repeated.  This can be
done by typing merely

     //

This shorthand stands for "the most recently used context search
expression."  It can also be used as the first string of the substitute
command, as in

     /string1/s//string2/

which will find the next occurrence of 'string1' and replace it by
'string2'.  This can save a lot of typing.  Similarly

     ??

means "scan backwards for the same expression."


File: ed.info,  Node: Change and Insert,  Next: Exercise 7,  Prev: Exercise 6,  Up: A Tutorial Introduction to the UNIX Text Editor

Change and Insert -- "c" and "i"
================================

This section discusses the "change" command

     c

which is used to change or replace a group of one or more lines, and the
"insert" command

     i

which is used for inserting a group of one or more lines.

"Change", written as

     c

is used to replace a number of lines with different lines, which are
typed in at the terminal.  For example, to change lines .'+1' through
'$' to something else, type

     .+1,$c
     ... _type the lines of text you want here_ ...
     .

The lines you type between the 'c' command and the .  will take the
place of the original lines between start line and end line.  This is
most useful in replacing a line or several lines which have errors in
them.

If only one line is specified in the 'c' command, then just that line is
replaced.  (You can type in as many replacement lines as you like.)
Notice the use of .  to end the input -- this works just like the .  in
the append command and must appear by itself on a new line.  If no line
number is given, line dot is replaced.  The value of dot is set to the
last line you typed in.

"Insert" is similar to append -- for instance

     /string/i
     ... _type the lines to be inserted here_ ...
     .

will insert the given text _before_ the next line that contains
"string".  The text between 'i' and .  is _inserted before_ the
specified line.  If no line number is specified dot is used.  Dot is set
to the last line inserted.


File: ed.info,  Node: Exercise 7,  Next: Moving text around,  Prev: Change and Insert,  Up: A Tutorial Introduction to the UNIX Text Editor

Exercise 7:
===========

"Change" is rather like a combination of delete followed by insert.
Experiment to verify that

     _start, end_ d
     i
     ... _text_ ...
     .

is almost the same as

     _start, end_ c
     ... _text_ ...
     .

These are not _precisely_ the same if line '$' gets deleted.  Check this
out.  What is dot?

Experiment with 'a' and 'i', to see that they are similar, but not the
same.  You will observe that

     _line-number_ a
     ... _text_ ...
     .

appends _after_ the given line, while

     _line-number_ i
     ... _text_ ...
     .

inserts _before_ it.  Observe that if no line number is given, 'i'
inserts before line dot, while 'a' appends after line dot.


File: ed.info,  Node: Moving text around,  Next: The global commands,  Prev: Exercise 7,  Up: A Tutorial Introduction to the UNIX Text Editor

Moving text around -- "m"
=========================

The "move" command 'm' is used for cutting and pasting -- it lets you
move a group of lines from one place to another in the buffer.  Suppose
you want to put the first three lines of the buffer at the end instead.
You could do it by saying:

     1,3w temp
     $r temp
     1,3d

(Do you see why?)  but you can do it a lot easier with the m command:

     1,3m$

The general case is

     _start line, end line_ m _after this line_

Notice that there is a third line to be specified -- the place where the
moved stuff gets put.  Of course the lines to be moved can be specified
by context searches; if you had

     First paragraph
     ...
     end of first paragraph.
     Second paragraph
     ...
     end of second paragraph.

you could reverse the two paragraphs like this:

     /Second/,/end of second/m/First/-1

Notice the '-1': the moved text goes _after_ the line mentioned.  Dot
gets set to the last line moved.


File: ed.info,  Node: The global commands,  Next: Special Characters,  Prev: Moving text around,  Up: A Tutorial Introduction to the UNIX Text Editor

The global commands "g" and "v"
===============================

The "global" command 'g' is used to execute one or more 'ed' commands on
all those lines in the buffer that match some specified string.  For
example

     g/peling/p

prints all lines that contain 'peling'.  More usefully,

     g/peling/s//pelling/gp

makes the substitution everywhere on the line, then prints each
corrected line.  Compare this to

     1,$s/peling/pelling/gp

which only prints the last line substituted.  Another subtle difference
is that the 'g' command does not give a '?' if 'peling' is not found
where the 's' command will.

There may be several commands (including 'a', 'c', 'i', 'r', 'w', but
not 'g'); in that case, every line except the last must end with a
backslash '\':

     g/xxx/.-1s/abc/def/\
     .+2s/ghi/jkl/\
     .-2,.p

makes changes in the lines before and after each line that contains
'xxx', then prints all three lines.

The 'v' command is the same as 'g', except that the commands are
executed on every line that does _not_ match the string following 'v':

     v/ /d

deletes every line that does not contain a blank.


File: ed.info,  Node: Special Characters,  Next: Summary,  Prev: The global commands,  Up: A Tutorial Introduction to the UNIX Text Editor

Special Characters
==================

You may have noticed that things just don't work right when you used
some characters like ., '*', '$', and others in context searches and the
substitute command.  The reason is rather complex, although the cure is
simple.  Basically, 'ed' treats these characters as special, with
special meanings.  For instance, _in a context search or the first
string of the substitute command only_, .  means "any character," not a
period, so

     /x.y/

means "a line with an 'x', _any character_, and a 'y'," _not_ just "a
line with an 'x', a period, and a 'y'."  A complete list of the special
characters that can cause trouble is the following:

     ^    .    $    [    *    \

_Warning:_ The backslash character '\' is special to 'ed'.  For safety's
sake, avoid it where possible.  If you have to use one of the special
characters in a substitute command, you can turn off its magic meaning
temporarily by preceding it with the backslash.  Thus

     s/\\\.\*/backslash dot star/

will change '\'.'*' into "backslash dot star".

Here is a hurried synopsis of the other special characters.  First, the
circumflex '^' signifies the beginning of a line.  Thus

     /^string/

finds 'string' only if it is at the beginning of a line: it will find

     string

but not

     the string ...

The dollar-sign '$' is just the opposite of the circumflex; it means the
end of a line:

     /string$/

will only find an occurrence of 'string' that is at the end of some
line.  This implies, of course, that

     /^string$/

will find only a line that contains just 'string', and

     /^.$/

finds a line containing exactly one character.

The character ., as we mentioned above, matches anything;

     /x.y/

matches any of

     x+y
     x-y
     x y
     x.y

This is useful in conjunction with '*', which is a repetition character;
'a*' is a shorthand for "any number of 'a''s," so .'*' matches any
number of anythings.  This is used like this:

     s/.*/stuff/

which changes an entire line, or

     s/.*,//

which deletes all characters in the line up to and including the last
comma.  (Since .'*' finds the longest possible match, this goes up to
the last comma.)

'[' is used with ']' to form "character classes"; for example,

     /[0123456789]/

matches any single digit -- any one of the characters inside the braces
will cause a match.  This can be abbreviated to '[0-9]'.

Finally, the '&' is another shorthand character -- it is used only on
the right-hand part of a substitute command where it means "whatever was
matched on the left-hand side".  It is used to save typing.  Suppose the
current line contained

     Now is the time

and you wanted to put parentheses around it.  You could just retype the
line, but this is tedious.  Or you could say

     s/^/(/
     s/$/)/

using your knowledge of '^' and '$'.  But the easiest way uses the '&':

     s/.*/(&)/

This says "match the whole line, and replace it by itself surrounded by
parentheses."  The '&' can be used several times in a line; consider
using

     s/.*/&?  &!!/

to produce

     Now is the time?  Now is the time!!

You don't have to match the whole line, of course: if the buffer
contains

     the end of the world

you could type

     /world/s//& is at hand/

to produce

     the end of the world is at hand

Observe this expression carefully, for it illustrates how to take
advantage of 'ed' to save typing.  The string '/world/' found the
desired line; the shorthand '//' found the same word in the line; and
the '&' saves you from typing it again.

The '&' is a special character only within the replacement text of a
substitute command, and has no special meaning elsewhere.  You can turn
off the special meaning of '&' by preceding it with a '\':

     s/ampersand/\&/

will convert the word "ampersand" into the literal symbol '&' in the
current line.


File: ed.info,  Node: Summary,  Prev: Special Characters,  Up: A Tutorial Introduction to the UNIX Text Editor

Summary of Commands and Line Numbers
====================================

The general form of 'ed' commands is the command name, perhaps preceded
by one or two line numbers, and, in the case of 'e', 'r', and 'w',
followed by a file name.  Only one command is allowed per line, but a
'p' command may follow any other command (except for 'e', 'r', 'w' and
'q').
'a'
     Append, that is, add lines to the buffer (at line dot, unless a
     different line is specified).  Appending continues until .  is
     typed on a new line.  Dot is set to the last line appended.

'c'
     Change the specified lines to the new text which follows.  The new
     lines are terminated by a ., as with 'a'.  If no lines are
     specified, replace line dot.  Dot is set to last line changed.

'd'
     Delete the lines specified.  If none are specified, delete line
     dot.  Dot is set to the first undeleted line, unless '$' is
     deleted, in which case dot is set to '$'.

'e'
     Edit new file.  Any previous contents of the buffer are thrown
     away, so issue a 'w' beforehand.

'f'
     Print remembered filename.  If a name follows 'f' the remembered
     name will be set to it.

'g'
     The command

          g/---/commands

     will execute the commands on those lines that contain --, which can
     be any context search expression.

'i'
     Insert lines before specified line (or dot) until a .  is typed on
     a new line.  Dot is set to last line inserted.

'm'
     Move lines specified to after the line named after 'm'.  Dot is set
     to the last line moved.

'p'
     Print specified lines.  If none specified, print line dot.  A
     single line number is equivalent to _line-number_ 'p'.  A single
     return prints .'+1', the next line.

'q'
     Quit 'ed'.  Wipes out all text in buffer if you give it twice in a
     row without first giving a 'w' command.

'r'
     Read a file into buffer (at end unless specified elsewhere.)  Dot
     set to last line read.

's'
     The command

          s/string1/string2/

     if no substitution took place, dot is not changed.  's' changes
     only the first occurrence of 'string1' on a line; to change all of
     them, type a 'g' after the final slash.

'v'
     The command

          v/---/commands

     executes commands on those lines that do not contain --.

'w'
     Write out buffer onto a file.  Dot is not changed.

'.='
     Print value of dot.  ('=' by itself prints the value of '$'.)

'!'
     The line

          !_command-line_

     causes _command-line_ to be executed as a UNIX command.

'/----/'
     Context search.  Search for next line which contains this string of
     characters.  Print it.  Dot is set to the line where string was
     found.  Search starts at .'+1', wraps around from '$' to 1, and
     continues to dot, if necessary.

'?----?'
     Context search in reverse direction.  Start search at .'-1', scan
     to 1, wrap around to '$'.


File: ed.info,  Node: Advanced Editing on UNIX,  Prev: A Tutorial Introduction to the UNIX Text Editor,  Up: Tutorial

Advanced Editing on UNIX
************************

by Brian W. Kernighan

This paper is meant to help secretaries, typists and programmers to make
effective use of the UNIX(R) facilities for preparing and editing text.
It provides explanations and examples of

   * special characters, line addressing and global commands in the
     editor 'ed';

   * commands for "cut and paste" operations on files and parts of
     files, including the 'mv', 'cp', 'cat' and 'rm' commands, and the
     'r', 'w' , 'm' and 't' commands of the editor;

   * editing scripts and editor-based programs like 'grep' and 'sed'.

Although the treatment is aimed at non-programmers, new users with any
background should find helpful hints on how to get their jobs done more
easily.

* Menu:

* INTRODUCTION::
* SPECIAL CHARACTERS::
* LINE ADDRESSING::
* GLOBAL COMMANDS::
* CUT AND PASTE WITH UNIX COMMANDS::
* CUT AND PASTE WITH THE EDITOR::
* SUPPORTING TOOLS::
* Acknowledgement::
* References::


File: ed.info,  Node: INTRODUCTION,  Next: SPECIAL CHARACTERS,  Prev: Advanced Editing on UNIX,  Up: Advanced Editing on UNIX

2.1 INTRODUCTION
================

Although UNIX provides remarkably effective tools for text editing, that
by itself is no guarantee that everyone will automatically make the most
effective use of them.  In particular, people who are not computer
specialists -- typists, secretaries, casual users -- often use the
system less effectively than they might.

This document is intended as a sequel to _A Tutorial Introduction to the
UNIX Text Editor_ [1], providing explanations and examples of how to
edit with less effort.  (You should also be familiar with the material
in _UNIX For Beginners_ [2].)  Further information on all commands
discussed here can be found in _The UNIX Programmer's Manual_ [3].

Examples are based on observations of users and the difficulties they
encounter.  Topics covered include special characters in searches and
substitute commands, line addressing, the global commands, and line
moving and copying.  There are also brief discussions of effective use
of related tools, like those for file manipulation, and those based on
'ed', like 'grep' and 'sed'.

A word of caution.  There is only one way to learn to use something, and
that is to _use_ it.  Reading a description is no substitute for trying
something.  A paper like this one should give you ideas about what to
try, but until you actually try something, you will not learn it.


File: ed.info,  Node: SPECIAL CHARACTERS,  Next: LINE ADDRESSING,  Prev: INTRODUCTION,  Up: Advanced Editing on UNIX

2.2 SPECIAL CHARACTERS
======================

The editor 'ed' is the primary interface to the system for many people,
so it is worthwhile to know how to get the most out of 'ed' for the
least effort.

The next few sections will discuss shortcuts and labor-saving devices.
Not all of these will be instantly useful to any one person, of course,
but a few will be, and the others should give you ideas to store away
for future use.  And as always, until you try these things, they will
remain theoretical knowledge, not something you have confidence in.

* Menu:

* The List Command:: ''l''
* The Substitute Command:: ''s''
* The Undo Command:: ''u''
* The Metacharacter:: ''.''
* The Backslash:: ''\''
* The Dollar Sign:: ''$''
* The Circumflex:: ''^''
* The Star:: ''*''
* The Brackets:: ''[]''
* The Ampersand:: ''&''
* Substituting Newlines::
* Joining Lines::
* Rearranging a Line:: '\(...\)'


File: ed.info,  Node: The List Command,  Next: The Substitute Command,  Prev: SPECIAL CHARACTERS,  Up: SPECIAL CHARACTERS

The List Command ''l''
----------------------

'ed' provides two commands for printing the contents of the lines you're
editing.  Most people are familiar with 'p', in combinations like

     1,$p

to print all the lines you're editing, or

     s/abc/def/p

to change 'abc' to 'def' on the current line.  Less familiar is the
"list" command 'l' (the letter '_l_'), which gives slightly more
information than 'p'.  In particular, 'l' makes visible characters that
are normally invisible, such as tabs and backspaces.  If you list a line
that contains some of these, 'l' will print each tab as > and each
backspace as <.  This makes it much easier to correct the sort of typing
mistake that inserts extra spaces adjacent to tabs, or inserts a
backspace followed by a space.

The 'l' command also 'folds' long lines for printing -- any line that
exceeds 72 characters is printed on multiple lines; each printed line
except the last is terminated by a backslash \, so you can tell it was
folded.  This is useful for printing long lines on short terminals.

Occasionally the 'l' command will print in a line a string of numbers
preceded by a backslash, such as \07 or \16.  These combinations are
used to make visible characters that normally don't print, like form
feed or vertical tab or bell.  Each such combination is a single
character.  When you see such characters, be wary -- they may have
surprising meanings when printed on some terminals.  Often their
presence means that your finger slipped while you were typing; you
almost never want them.


File: ed.info,  Node: The Substitute Command,  Next: The Undo Command,  Prev: The List Command,  Up: SPECIAL CHARACTERS

The Substitute Command ''s''
----------------------------

Most of the next few sections will be taken up with a discussion of the
substitute command 's'.  Since this is the command for changing the
contents of individual lines, it probably has the most complexity of any
'ed' command, and the most potential for effective use.

As the simplest place to begin, recall the meaning of a trailing 'g'
after a substitute command.  With

     s/this/that/

and

     s/this/that/g

the first one replaces the _first_ 'this' on the line with 'that'.  If
there is more than one 'this' on the line, the second form with the
trailing 'g' changes _all_ of them.

Either form of the 's' command can be followed by 'p' or 'l' to 'print'
or 'list' (as described in the previous section) the contents of the
line:

     s/this/that/p
     s/this/that/l
     s/this/that/gp
     s/this/that/gl

are all legal, and mean slightly different things.  Make sure you know
what the differences are.

Of course, any 's' command can be preceded by one or two 'line numbers'
to specify that the substitution is to take place on a group of lines.
Thus

     1,$s/mispell/misspell/

changes the _first_ occurrence of 'mispell' to 'misspell' on every line
of the file.  But

     1,$s/mispell/misspell/g

changes _every_ occurrence in every line (and this is more likely to be
what you wanted in this particular case).

You should also notice that if you add a 'p' or 'l' to the end of any of
these substitute commands, only the last line that got changed will be
printed, not all the lines.  We will talk later about how to print all
the lines that were modified.


File: ed.info,  Node: The Undo Command,  Next: The Metacharacter,  Prev: The Substitute Command,  Up: SPECIAL CHARACTERS

The Undo Command ''u''
----------------------

Occasionally you will make a substitution in a line, only to realize too
late that it was a ghastly mistake.  The 'undo' command 'u' lets you
'undo' the last substitution: the last line that was substituted can be
restored to its previous state by typing the command

     u


File: ed.info,  Node: The Metacharacter,  Next: The Backslash,  Prev: The Undo Command,  Up: SPECIAL CHARACTERS

The Metacharacter ''.''
-----------------------

As you have undoubtedly noticed when you use 'ed', certain characters
have unexpected meanings when they occur in the left side of a
substitute command, or in a search for a particular line.  In the next
several sections, we will talk about these special characters, which are
often called 'metacharacters'.

The first one is the period '.'.  On the left side of a substitute
command, or in a search with '/.../', '.'  stands for _any_ single
character.  Thus the search

     /x.y/

finds any line where 'x' and 'y' occur separated by a single character,
as in

     x+y
     x-y
     x y
     x.y

and so on.  (We will use to stand for a space whenever we need to make
it visible.)

Since '.'  matches a single character, that gives you a way to deal with
funny characters printed by 'l'.  Suppose you have a line that, when
printed with the 'l' command, appears as

     ... th\07is ...

and you want to get rid of the \07 (which represents the bell character,
by the way).

The most obvious solution is to try

     s/\07//

but this will fail.  (Try it.)  The brute force solution, which most
people would now take, is to re-type the entire line.  This is
guaranteed, and is actually quite a reasonable tactic if the line in
question isn't too big, but for a very long line, re-typing is a bore.
This is where the metacharacter '.'  comes in handy.  Since '\07' really
represents a single character, if we say

     s/th.is/this/

the job is done.  The '.'  matches the mysterious character between the
'h' and the 'i', _whatever_ it is.

Bear in mind that since '.'  matches any single character, the command

     s/./,/

converts the first character on a line into a ',', which very often is
not what you intended.

As is true of many characters in 'ed', the '.'  has several meanings,
depending on its context.  This line shows all three:

     .s/././

The first '.'  is a line number, the number of the line we are editing,
which is called 'line dot'.  (We will discuss line dot more in Section
3.)  The second '.'  is a metacharacter that matches any single
character on that line.  The third '.'  is the only one that really is
an honest literal period.  On the _right_ side of a substitution, '.'
is not special.  If you apply this command to the line

     Now is the time.

the result will be

     .ow is the time.

which is probably not what you intended.


File: ed.info,  Node: The Backslash,  Next: The Dollar Sign,  Prev: The Metacharacter,  Up: SPECIAL CHARACTERS

The Backslash '\'
-----------------

Since a period means 'any character', the question naturally arises of
what to do when you really want a period.  For example, how do you
convert the line

     Now is the time.

into

     Now is the time?

The backslash '\' does the job.  A backslash turns off any special
meaning that the next character might have; in particular, '\.'
converts the '.'  from a 'match anything' into a period, so you can use
it to replace the period in

     Now is the time.

like this:

     s/\./?/

The pair of characters '\.'  is considered by 'ed' to be a single real
period.

The backslash can also be used when searching for lines that contain a
special character.  Suppose you are looking for a line that contains

     .PP

The search

     /.PP/

isn't adequate, for it will find a line like

     THE APPLICATION OF ...

because the '.'  matches the letter 'A'. But if you say

     /\.PP/

you will find only lines that contain '.PP'.

The backslash can also be used to turn off special meanings for
characters other than '.'.  For example, consider finding a line that
contains a backslash.  The search

     /\/

won't work, because the '\' isn't a literal '\', but instead means that
the second '/' no longer delimits the search.  But by preceding a
backslash with another one, you can search for a literal backslash.
Thus

     /\\/

does work.  Similarly, you can search for a forward slash '/' with

     /\//

The backslash turns off the meaning of the immediately following '/' so
that it doesn't terminate the /.../ construction prematurely.

As an exercise, before reading further, find two substitute commands
each of which will convert the line

     \x\.\y

into the line

     \x\y

Here are several solutions; verify that each works as advertised.

     s/\\\.//
     s/x../x/
     s/..y/y/

A couple of miscellaneous notes about backslashes and special
characters.  First, you can use any character to delimit the pieces of
an 's' command: there is nothing sacred about slashes.  (But you must
use slashes for context searching.)  For instance, in a line that
contains a lot of slashes already, like

     //exec //sys.fort.go // etc...

you could use a colon as the delimiter -- to delete all the slashes,
type

     s:/::g

Second, if _#_ and _@_ are your character erase and line kill
characters, you have to type _\#_ and _\@_; this is true whether you're
talking to 'ed' or any other program.

When you are adding text with 'a' or 'i' or 'c', backslash is not
special, and you should only put in one backslash for each one you
really want.


File: ed.info,  Node: The Dollar Sign,  Next: The Circumflex,  Prev: The Backslash,  Up: SPECIAL CHARACTERS

The Dollar Sign ''$''
---------------------

The next metacharacter, the '$', stands for 'the end of the line'.  As
its most obvious use, suppose you have the line

     Now is the

and you wish to add the word 'time' to the end.  Use the $ like this:

     s/$/ time/

to get

     Now is the time

Notice that a space is needed before 'time' in the substitute command,
or you will get

     Now is thetime

As another example, replace the second comma in the following line with
a period without altering the first:

     Now is the time, for all good men,

The command needed is

     s/,$/./

The $ sign here provides context to make specific which comma we mean.
Without it, of course, the 's' command would operate on the first comma
to produce

     Now is the time. for all good men,

As another example, to convert

     Now is the time.

into

     Now is the time?

as we did earlier, we can use

     s/.$/?/

Like '.', the '$' has multiple meanings depending on context.  In the
line

     $s/$/$/

the first '$' refers to the last line of the file, the second refers to
the end of that line, and the third is a literal dollar sign, to be
added to that line.


File: ed.info,  Node: The Circumflex,  Next: The Star,  Prev: The Dollar Sign,  Up: SPECIAL CHARACTERS

The Circumflex ''^''
--------------------

The circumflex (or hat or caret) '^' stands for the beginning of the
line.  For example, suppose you are looking for a line that begins with
'the'.  If you simply say

     /the/

you will in all likelihood find several lines that contain 'the' in the
middle before arriving at the one you want.  But with

     /^the/

you narrow the context, and thus arrive at the desired one more easily.

The other use of '^' is of course to enable you to insert something at
the beginning of a line:

     s/^/ /

places a space at the beginning of the current line.

Metacharacters can be combined.  To search for a line that contains
_only_ the characters

     .PP

you can use the command

     /^\.PP$/


File: ed.info,  Node: The Star,  Next: The Brackets,  Prev: The Circumflex,  Up: SPECIAL CHARACTERS

The Star ''*''
--------------

Suppose you have a line that looks like this:

     _text_  x        y  _text_

where _text_ stands for lots of text, and there are some indeterminate
number of spaces between the x and the y.  Suppose the job is to replace
all the spaces between x and y by a single space.  The line is too long
to retype, and there are too many spaces to count.  What now?

This is where the metacharacter '*' comes in handy.  A character
followed by a star stands for as many consecutive occurrences of that
character as possible.  To refer to all the spaces at once, say

     s/x *y/x y/

The construction ' *' means 'as many spaces as possible'.  Thus 'x *y'
means 'an x, as many spaces as possible, then a y'.

The star can be used with any character, not just space.  If the
original example was instead

     _text_  x-----y  _text_

then all '-' signs can be replaced by a single space with the command

     s/x-*y/x y/

Finally, suppose that the line was

     _text_  x........y  _text_

Can you see what trap lies in wait for the unwary?  If you blindly type

     s/x.*y/x y/

what will happen?  The answer, naturally, is that it depends.  If there
are no other x's or y's on the line, then everything works, but it's
blind luck, not good management.  Remember that '.'  matches any single
character?  Then '.*' matches as many single characters as possible, and
unless you're careful, it can eat up a lot more of the line than you
expected.  If the line was, for example, like this:

     _text_  x  _text_   x........y   _text_  y  _text_

then saying

     s/x.*y/x y/

will take everything from the _first_ 'x' to the _last_ 'y', which, in
this example, is undoubtedly more than you wanted.

The solution, of course, is to turn off the special meaning of '.'  with
'\.':

     s/x\.*y/x y/

Now everything works, for '\.*' means 'as many _periods_ as possible'.

There are times when the pattern '.*' is exactly what you want.  For
example, to change

     Now is the time for all good men ...

into

     Now is the time.

use '.*' to eat up everything after the 'for':

     s/ for.*/./

There are a couple of additional pitfalls associated with '*' that you
should be aware of.  Most notable is the fact that 'as many as possible'
means _zero_ or more.  The fact that zero is a legitimate possibility is
sometimes rather surprising.  For example, if our line contained

     _text_  xy  _text_  x        y  _text_

and we said

     s/x *y/x y/

the _first_ 'xy' matches this pattern, for it consists of an 'x', zero
spaces, and a 'y'.  The result is that the substitute acts on the first
'xy', and does not touch the later one that actually contains some
intervening spaces.

The way around this, if it matters, is to specify a pattern like

     /x  *y/

which says 'an x, a space, then as many more spaces as possible, then a
y', in other words, one or more spaces.

The other startling behavior of '*' is again related to the fact that
zero is a legitimate number of occurrences of something followed by a
star.  The command

     s/x*/y/g

when applied to the line

     abcdef

produces

     yaybycydyeyfy

which is almost certainly not what was intended.  The reason for this
behavior is that zero is a legal number of matches, and there are no x's
at the beginning of the line (so that gets converted into a 'y'), nor
between the 'a' and the 'b' (so that gets converted into a 'y'), nor ...
and so on.  Make sure you really want zero matches; if not, in this case
write

     s/xx*/y/g

'xx*' is one or more x's.


File: ed.info,  Node: The Brackets,  Next: The Ampersand,  Prev: The Star,  Up: SPECIAL CHARACTERS

The Brackets ''[]''
-------------------

Suppose that you want to delete any numbers that appear at the beginning
of all lines of a file.  You might first think of trying a series of
commands like

     1,$s/^1*//
     1,$s/^2*//
     1,$s/^3*//

and so on, but this is clearly going to take forever if the numbers are
at all long.  Unless you want to repeat the commands over and over until
finally all numbers are gone, you must get all the digits on one pass.
This is the purpose of the brackets '[' and ']'.

The construction

     [0123456789]

matches any single digit -- the whole thing is called a 'character
class'.  With a character class, the job is easy.  The pattern
'[0123456789]*' matches zero or more digits (an entire number), so

     1,$s/^[0123456789]*//

deletes all digits from the beginning of all lines.

Any characters can appear within a character class, and just to confuse
the issue there are essentially no special characters inside the
brackets; even the backslash doesn't have a special meaning.  To search
for special characters, for example, you can say

     /[.\$^[]/

Within [...], the '[' is not special.  To get a ']' into a character
class, make it the first character.

It's a nuisance to have to spell out the digits, so you can abbreviate
them as [0-9]; similarly, [a-z] stands for the lower case letters, and
[A-Z] for upper case.

As a final frill on character classes, you can specify a class that
means 'none of the following characters'.  This is done by beginning the
class with a '^':

     [^0-9]

stands for 'any character _except_ a digit'.  Thus you might find the
first line that doesn't begin with a tab or space by a search like

     /^[^(space)(tab)]/

Within a character class, the circumflex has a special meaning only if
it occurs at the beginning.  Just to convince yourself, verify that

     /^[^^]/

finds a line that doesn't begin with a circumflex.


File: ed.info,  Node: The Ampersand,  Next: Substituting Newlines,  Prev: The Brackets,  Up: SPECIAL CHARACTERS

The Ampersand ''&''
-------------------

The ampersand '&' is used primarily to save typing.  Suppose you have
the line

     Now is the time

and you want to make it

     Now is the best time

Of course you can always say

     s/the/the best/

but it seems silly to have to repeat the 'the'.  The '&' is used to
eliminate the repetition.  On the _right side_ of a substitute, the
ampersand means 'whatever was just matched', so you can say

     s/the/& best/

and the '&' will stand for 'the'.  Of course this isn't much of a saving
if the thing matched is just 'the', but if it is something truly long or
awful, or if it is something like '.*' which matches a lot of text, you
can save some tedious typing.  There is also much less chance of making
a typing error in the replacement text.  For example, to parenthesize a
line, regardless of its length,

     s/.*/(&)/

The ampersand can occur more than once on the right side:

     s/the/& best and & worst/

makes

     Now is the best and the worst time

and

     s/.*/&? &!!/

converts the original line into

     Now is the time? Now is the time!!

To get a literal ampersand, naturally the backslash is used to turn off
the special meaning:

     s/ampersand/\&/

converts the word into the symbol.  Notice that '&' is not special on
the left side of a substitute, only on the _right_ side.


File: ed.info,  Node: Substituting Newlines,  Next: Joining Lines,  Prev: The Ampersand,  Up: SPECIAL CHARACTERS

Substituting Newlines
---------------------

'ed' provides a facility for splitting a single line into two or more
shorter lines by 'substituting in a newline'.  As the simplest example,
suppose a line has gotten unmanageably long because of editing (or
merely because it was unwisely typed).  If it looks like

     _text_    xy   _text_

you can break it between the 'x' and the 'y' like this:

     s/xy/x\
     y/

This is actually a single command, although it is typed on two lines.
Bearing in mind that '\' turns off special meanings, it seems relatively
intuitive that a '\' at the end of a line would make the newline there
no longer special.

You can in fact make a single line into several lines with this same
mechanism.  As a large example, consider underlining the word 'very' in
a long line by splitting 'very' onto a separate line, and preceding it
by the 'roff' or 'nroff' formatting command '.ul'.

     _text_  a very big  _text_

The command

     s/ very /\
     .ul\
     very\
     /

converts the line into four shorter lines, preceding the word 'very' by
the line '.ul', and eliminating the spaces around the 'very', all at the
same time.

When a newline is substituted in, dot is left pointing at the last line
created.


File: ed.info,  Node: Joining Lines,  Next: Rearranging a Line,  Prev: Substituting Newlines,  Up: SPECIAL CHARACTERS

Joining Lines
-------------

Lines may also be joined together, but this is done with the 'j' command
instead of 's'.  Given the lines

     Now is
      the time

and supposing that dot is set to the first of them, then the command

     j

joins them together.  No blanks are added, which is why we carefully
showed a blank at the beginning of the second line.

All by itself, a 'j' command joins line dot to line dot+1, but any
contiguous set of lines can be joined.  Just specify the starting and
ending line numbers.  For example,

     1,$jp

joins all the lines into one big one and prints it.  (More on line
numbers in Section 3.)


File: ed.info,  Node: Rearranging a Line,  Prev: Joining Lines,  Up: SPECIAL CHARACTERS

Rearranging a Line with ''\(...\)''
-----------------------------------

(This section should be skipped on first reading.)  Recall that '&' is a
shorthand that stands for whatever was matched by the left side of an
's' command.  In much the same way you can capture separate pieces of
what was matched; the only difference is that you have to specify on the
left side just what pieces you're interested in.

Suppose, for instance, that you have a file of lines that consist of
names in the form

     Smith, A. B.
     Jones, C.

and so on, and you want the initials to precede the name, as in

     A. B. Smith
     C. Jones

It is possible to do this with a series of editing commands, but it is
tedious and error-prone.  (It is instructive to figure out how it is
done, though.)

The alternative is to 'tag' the pieces of the pattern (in this case, the
last name, and the initials), and then rearrange the pieces.  On the
left side of a substitution, if part of the pattern is enclosed between
\( and \), whatever matched that part is remembered, and available for
use on the right side.  On the right side, the symbol '\1' refers to
whatever matched the first \(...\) pair, '\2' to the second \(...\), and
so on.

The command

     1,$s/^\([^,]*\), *\(.*\)/\2 \1/

although hard to read, does the job.  The first \(...\) matches the last
name, which is any string up to the comma; this is referred to on the
right side with '\1'.  The second \(...\) is whatever follows the comma
and any spaces, and is referred to as '\2'.

Of course, with any editing sequence this complicated, it's foolhardy to
simply run it and hope.  The global commands 'g' and 'v' discussed in
section 4 provide a way for you to print exactly those lines which were
affected by the substitute command, and thus verify that it did what you
wanted in all cases.


File: ed.info,  Node: LINE ADDRESSING,  Next: GLOBAL COMMANDS,  Prev: SPECIAL CHARACTERS,  Up: Advanced Editing on UNIX

2.3 LINE ADDRESSING IN THE EDITOR
=================================

The next general area we will discuss is that of line addressing in
'ed', that is, how you specify what lines are to be affected by editing
commands.  We have already used constructions like

     1,$s/x/y/

to specify a change on all lines.  And most users are long since
familiar with using a single newline (or return) to print the next line,
and with

     /thing/

to find a line that contains 'thing'.  Less familiar, surprisingly
enough, is the use of

     ?thing?

to scan _backwards_ for the previous occurrence of 'thing'.  This is
especially handy when you realize that the thing you want to operate on
is back up the page from where you are currently editing.

The slash and question mark are the only characters you can use to
delimit a context search, though you can use essentially any character
in a substitute command.

* Menu:

* Address Arithmetic::
* Repeated Searches::
* Default Addresses:: Default Line Numbers and the Value of Dot
* Semicolon:: '';''
* Interrupting the Editor::


File: ed.info,  Node: Address Arithmetic,  Next: Repeated Searches,  Prev: LINE ADDRESSING,  Up: LINE ADDRESSING

Address Arithmetic
------------------

The next step is to combine the line numbers like '.', '$', '/.../' and
'?...?'  with '+' and '-'.  Thus

     $-1

is a command to print the next to last line of the current file (that
is, one line before line '$').  For example, to recall how far you got
in a previous editing session,

     $-5,$p

prints the last six lines.  (Be sure you understand why it's six, not
five.)  If there aren't six, of course, you'll get an error message.

As another example,

     .-3,.+3p

prints from three lines before where you are now (at line dot) to three
lines after, thus giving you a bit of context.  By the way, the '+' can
be omitted:

     .-3,.3p

is absolutely identical in meaning.

Another area in which you can save typing effort in specifying lines is
to use '-' and '+' as line numbers by themselves.

     -

by itself is a command to move back up one line in the file.  In fact,
you can string several minus signs together to move back up that many
lines:

     ---

moves up three lines, as does '-3'.  Thus

     -3,+3p

is also identical to the examples above.

Since '-' is shorter than '.-1', constructions like

     -,.s/bad/good/

are useful.  This changes 'bad' to 'good' on the previous line and on
the current line.

'+' and '-' can be used in combination with searches using '/.../' and
'?...?', and with '$'.  The search

     /thing/--

finds the line containing 'thing', and positions you two lines before
it.


File: ed.info,  Node: Repeated Searches,  Next: Default Addresses,  Prev: Address Arithmetic,  Up: LINE ADDRESSING

Repeated Searches
-----------------

Suppose you ask for the search

     /horrible thing/

and when the line is printed you discover that it isn't the horrible
thing that you wanted, so it is necessary to repeat the search again.
You don't have to re-type the search, for the construction

     //

is a shorthand for 'the previous thing that was searched for', whatever
it was.  This can be repeated as many times as necessary.  You can also
go backwards:

     ??

searches for the same thing, but in the reverse direction.

Not only can you repeat the search, but you can use '//' as the left
side of a substitute command, to mean 'the most recent pattern'.

     /horrible thing/
     ... _ed prints line with 'horrible thing'_ ...
     s//good/p

To go backwards and change a line, say

     ??s//good/

Of course, you can still use the '&' on the right hand side of a
substitute to stand for whatever got matched:

     //s//& &/p

finds the next occurrence of whatever you searched for last, replaces it
by two copies of itself, then prints the line just to verify that it
worked.


File: ed.info,  Node: Default Addresses,  Next: Semicolon,  Prev: Repeated Searches,  Up: LINE ADDRESSING

Default Line Numbers and the Value of Dot
-----------------------------------------

One of the most effective ways to speed up your editing is always to
know what lines will be affected by a command if you don't specify the
lines it is to act on, and on what line you will be positioned (i.e.,
the value of dot) when a command finishes.  If you can edit without
specifying unnecessary line numbers, you can save a lot of typing.

As the most obvious example, if you issue a search command like

     /thing/

you are left pointing at the next line that contains 'thing'.  Then no
address is required with commands like 's' to make a substitution on
that line, or 'p' to print it, or 'l' to list it, or 'd' to delete it,
or 'a' to append text after it, or 'c' to change it, or 'i' to insert
text before it.

What happens if there was no 'thing'?  Then you are left right where you
were -- dot is unchanged.  This is also true if you were sitting on the
only 'thing' when you issued the command.  The same rules hold for
searches that use '?...?'; the only difference is the direction in which
you search.

The delete command 'd' leaves dot pointing at the line that followed the
last deleted line.  When line '$' gets deleted, however, dot points at
the _new_ line '$'.

The line-changing commands 'a', 'c' and 'i' by default all affect the
current line -- if you give no line number with them, 'a' appends text
after the current line, 'c' changes the current line, and 'i' inserts
text before the current line.

'a', 'c', and 'i' behave identically in one respect -- when you stop
appending, changing or inserting, dot points at the last line entered.
This is exactly what you want for typing and editing on the fly.  For
example, you can say

       a
       ... _text_ ...
       ... _botch_ ...     (minor error)
       .
       s/_botch_/_correct_/(fix botched line)
       a
       ... _more text_
       ...

without specifying any line number for the substitute com- mand or for
the second append command.  Or you can say

       a
       ... _text_ ...
       ... _horrible botch_ ...   (major error)
       .
       c                          (replace entire line)
       ... _fixed up line_ ...

You should experiment to determine what happens if you add _no_ lines
with 'a', 'c' or 'i'.

The 'r' command will read a file into the text being edited, either at
the end if you give no address, or after the specified line if you do.
In either case, dot points at the last line read in.  Remember that you
can even say '0r' to read a file in at the beginning of the text.  (You
can also say '0a' or '1i' to start adding text at the beginning.)

The 'w' command writes out the entire file.  If you precede the command
by one line number, that line is written, while if you precede it by two
line numbers, that range of lines is written.  The 'w' command does
_not_ change dot: the current line remains the same, regardless of what
lines are written.  This is true even if you say something like

     /^\.AB/,/^\.AE/w abstract

which involves a context search.

Since the 'w' command is so easy to use, you should save what you are
editing regularly as you go along just in case the system crashes, or in
case you do something foolish, like clobbering what you're editing.

The least intuitive behavior, in a sense, is that of the 's' command.
The rule is simple -- you are left sitting on the last line that got
changed.  If there were no changes, then dot is unchanged.

To illustrate, suppose that there are three lines in the buffer, and you
are sitting on the middle one:

     x1
     x2
     x3

Then the command

     -,+s/x/y/p

prints the third line, which is the last one changed.  But if the three
lines had been

     x1
     y2
     y3

and the same command had been issued while dot pointed at the second
line, then the result would be to change and print only the first line,
and that is where dot would be set.


File: ed.info,  Node: Semicolon,  Next: Interrupting the Editor,  Prev: Default Addresses,  Up: LINE ADDRESSING

Semicolon ';'
-------------

Searches with '/.../' and '?...?'  start at the current line and move
forward or backward respectively until they either find the pattern or
get back to the current line.  Sometimes this is not what is wanted.
Suppose, for example, that the buffer contains lines like this:

     .
     .
     .
     ab
     .
     .
     .
     bc
     .
     .

Starting at line 1, one would expect that the command

     /a/,/b/p

prints all the lines from the 'ab' to the 'bc' inclusive.  Actually this
is not what happens.  _Both_ searches (for 'a' and for 'b') start from
the same point, and thus they both find the line that contains 'ab'.
The result is to print a single line.  Worse, if there had been a line
with a 'b' in it before the 'ab' line, then the print command would be
in error, since the second line number would be less than the first, and
it is illegal to try to print lines in reverse order.

This is because the comma separator for line numbers doesn't set dot as
each address is processed; each search starts from the same place.  In
'ed', the semicolon ';' can be used just like comma, with the single
difference that use of a semicolon forces dot to be set at that point as
the line numbers are being evaluated.  In effect, the semicolon 'moves'
dot.  Thus in our example above, the command

     /a/;/b/p

prints the range of lines from 'ab' to 'bc', because after the 'a' is
found, dot is set to that line, and then 'b' is searched for, starting
beyond that line.

This property is most often useful in a very simple situation.  Suppose
you want to find the _second_ occurrence of 'thing'.  You could say

     /thing/
     //

but this prints the first occurrence as well as the second, and is a
nuisance when you know very well that it is only the second one you're
interested in.  The solution is to say

     /thing/;//

This says to find the first occurrence of 'thing', set dot to that line,
then find the second and print only that.

Closely related is searching for the second previous occurrence of
something, as in

     ?something?;??

Printing the third or fourth or ... in either direction is left as an
exercise.

Finally, bear in mind that if you want to find the first occurrence of
something in a file, starting at an arbitrary place within the file, it
is not sufficient to say

     1;/thing/

because this fails if 'thing' occurs on line 1.  But it is possible to
say

     0;/thing/

(one of the few places where 0 is a legal line number), for this starts
the search at line 1.


File: ed.info,  Node: Interrupting the Editor,  Prev: Semicolon,  Up: LINE ADDRESSING

Interrupting the Editor
-----------------------

As a final note on what dot gets set to, you should be aware that if you
hit the interrupt or delete or rubout or break key while 'ed' is doing a
command, things are put back together again and your state is restored
as much as possible to what it was before the command began.  Naturally,
some changes are irrevocable -- if you are reading or writing a file or
making substitutions or deleting lines, these will be stopped in some
clean but unpredictable state in the middle (which is why it is not
usually wise to stop them).  Dot may or may not be changed.

Printing is more clear cut.  Dot is not changed until the printing is
done.  Thus if you print until you see an interesting line, then hit
delete, you are not sitting on that line or even near it.  Dot is left
where it was when the 'p' command was started.


File: ed.info,  Node: GLOBAL COMMANDS,  Next: CUT AND PASTE WITH UNIX COMMANDS,  Prev: LINE ADDRESSING,  Up: Advanced Editing on UNIX

2.4 GLOBAL COMMANDS
===================

The global commands 'g' and 'v' are used to perform one or more editing
commands on all lines that either contain ('g') or don't contain ('v') a
specified pattern.

* Menu:

* The Global Command List::
* Multi-line Global Commands::


File: ed.info,  Node: The Global Command List,  Next: Multi-line Global Commands,  Prev: GLOBAL COMMANDS,  Up: GLOBAL COMMANDS

The Global Command List
-----------------------

As the simplest example, the command

     g/UNIX/p

prints all lines that contain the word 'UNIX'. The pattern that goes
between the slashes can be anything that could be used in a line search
or in a substitute command; exactly the same rules and limitations
apply.

As another example, then,

     g/^\./p

prints all the formatting commands in a file (lines that begin with
'.').

The 'v' command is identical to 'g', except that it operates on those
line that do _not_ contain an occurrence of the pattern.  (Don't look
too hard for mnemonic significance to the letter 'v'.)  So

     v/^\./p

prints all the lines that don't begin with '.'  -- the actual text
lines.

The command that follows 'g' or 'v' can be anything:

     g/^\./d

deletes all lines that begin with '.', and

     g/^$/d

deletes all empty lines.

Probably the most useful command that can follow a global is the
substitute command, for this can be used to make a change and print each
affected line for verification.  For example, we could change the word
'Unix' to 'UNIX' everywhere, and verify that it really worked, with

     g/Unix/s//UNIX/gp

Notice that we used '//' in the substitute command to mean 'the previous
pattern', in this case, 'Unix'.  The 'p' command is done on every line
that matches the pattern, not just those on which a substitution took
place.

The global command operates by making two passes over the file.  On the
first pass, all lines that match the pattern are marked.  On the second
pass, each marked line in turn is examined, dot is set to that line, and
the command executed.  This means that it is possible for the command
that follows a 'g' or 'v' to use addresses, set dot, and so on, quite
freely.

     g/^\.PP/+

prints the line that follows each '.PP' command (the signal for a new
paragraph in some formatting packages).  Remember that '+' means 'one
line past dot'.  And

     g/topic/?^\.SH?1

searches for each line that contains 'topic', scans backwards until it
finds a line that begins '.SH' (a section heading) and prints the line
that follows that, thus showing the section headings under which 'topic'
is mentioned.

Finally,

     g/^\.EQ/+,/^\.EN/-p

prints all the lines that lie between lines beginning with '.EQ' and
'.EN' formatting commands.

The 'g' and 'v' commands can also be preceded by line numbers, in which
case the lines searched are only those in the range specified.


File: ed.info,  Node: Multi-line Global Commands,  Prev: The Global Command List,  Up: GLOBAL COMMANDS

Multi-line Global Commands
--------------------------

It is possible to do more than one command under the control of a global
command, although the syntax for expressing the operation is not
especially natural or pleasant.  As an example, suppose the task is to
change 'x' to 'y' and 'a' to 'b' on all lines that contain 'thing'.
Then

     g/thing/s/x/y/\
     s/a/b/

is sufficient.  The '\' signals the 'g' command that the set of commands
continues on the next line; it terminates on the first line that does
not end with '\'.  (As a minor blemish, you can't use a substitute
command to insert a newline within a g command.)

You should watch out for this problem: the command

     g/x/s//y/\
     s/a/b/

does not work as you expect.  The remembered pattern is the last pattern
that was actually executed, so sometimes it will be 'x' (as expected),
and sometimes it will be 'a' (not expected).  You must spell it out,
like this:

     g/x/s/x/y/\
     s/a/b/

It is also possible to execute 'a', 'c' and 'i' commands under a global
command; as with other multi-line constructions, all that is needed is
to add a '\' at the end of each line except the last.  Thus to add a
'.nf' and '.sp' command before each '.EQ' line, type

     g/^\.EQ/i\
     .nf\
     .sp

There is no need for a final line containing a '.'  to terminate the 'i'
command, unless there are further commands being done under the global.
On the other hand, it does no harm to put it in either.


File: ed.info,  Node: CUT AND PASTE WITH UNIX COMMANDS,  Next: CUT AND PASTE WITH THE EDITOR,  Prev: GLOBAL COMMANDS,  Up: Advanced Editing on UNIX

2.5 CUT AND PASTE WITH UNIX COMMANDS
====================================

One editing area in which non-programmers seem not very confident is in
what might be called 'cut and paste' operations -- changing the name of
a file, making a copy of a file somewhere else, moving a few lines from
one place to another in a file, inserting one file in the middle of
another, splitting a file into pieces, and splicing two or more files
together.

Yet most of these operations are actually quite easy, if you keep your
wits about you and go cautiously.  The next several sections talk about
cut and paste.  We will begin with the UNIX commands for moving entire
files around, then discuss 'ed' commands for operating on pieces of
files.

* Menu:

* Changing the Name of a File::
* Making a Copy of a File::
* Removing a File::
* Putting Two or More Files Together::
* Adding Something to the End of a File::


File: ed.info,  Node: Changing the Name of a File,  Next: Making a Copy of a File,  Prev: CUT AND PASTE WITH UNIX COMMANDS,  Up: CUT AND PASTE WITH UNIX COMMANDS

Changing the Name of a File
---------------------------

You have a file named 'memo' and you want it to be called 'paper'
instead.  How is it done?

The UNIX program that renames files is called 'mv' (for 'move'); it
'moves' the file from one name to another, like this:

     mv  memo  paper

That's all there is to it: 'mv' from the old name to the new name.

     mv  oldname  newname

Warning: if there is already a file around with the new name, its
present contents will be silently clobbered by the information from the
other file.  The one exception is that you can't move a file to itself
--

     mv  x  x

is illegal.


File: ed.info,  Node: Making a Copy of a File,  Next: Removing a File,  Prev: Changing the Name of a File,  Up: CUT AND PASTE WITH UNIX COMMANDS

Making a Copy of a File
-----------------------

Sometimes what you want is a copy of a file -- an entirely fresh
version.  This might be because you want to work on a file, and yet save
a copy in case something gets fouled up, or just because you're
paranoid.

In any case, the way to do it is with the 'cp' command.  ('cp' stands
for 'copy'; the system is big on short command names, which are
appreciated by heavy users, but sometimes a strain for novices.)
Suppose you have a file called 'good' and you want to save a copy before
you make some dramatic editing changes.  Choose a name -- 'savegood'
might be acceptable -- then type

     cp  good  savegood

This copies 'good' onto 'savegood', and you now have two identical
copies of the file 'good'.  (If 'savegood' previously contained
something, it gets overwritten.)

Now if you decide at some time that you want to get back to the original
state of 'good', you can say

     mv  savegood  good

(if you're not interested in 'savegood' any more), or

     cp  savegood  good

if you still want to retain a safe copy.

In summary, 'mv' just renames a file; 'cp' makes a duplicate copy.  Both
of them clobber the 'target' file if it already exists, so you had
better be sure that's what you want to do _before_ you do it.


File: ed.info,  Node: Removing a File,  Next: Putting Two or More Files Together,  Prev: Making a Copy of a File,  Up: CUT AND PASTE WITH UNIX COMMANDS

Removing a File
---------------

If you decide you are really done with a file forever, you can remove it
with the 'rm' command:

     rm  savegood

throws away (irrevocably) the file called 'savegood'.


File: ed.info,  Node: Putting Two or More Files Together,  Next: Adding Something to the End of a File,  Prev: Removing a File,  Up: CUT AND PASTE WITH UNIX COMMANDS

Putting Two or More Files Together
----------------------------------

The next step is the familiar one of collecting two or more files into
one big one.  This will be needed, for example, when the author of a
paper decides that several sections need to be combined into one.  There
are several ways to do it, of which the cleanest, once you get used to
it, is a program called 'cat'.  (Not _all_ programs have two-letter
names.)  'cat' is short for 'concatenate', which is exactly what we want
to do.

Suppose the job is to combine the files 'file1' and 'file2' into a
single file called 'bigfile'.  If you say

     cat  file

the contents of 'file' will get printed on your terminal.

If you say

     cat  file1  file2

the contents of 'file1' and then the contents of 'file2' will _both_ be
printed on your terminal, in that order.  So 'cat' combines the files,
all right, but it's not much help to print them on the terminal -- we
want them in 'bigfile'.

Fortunately, there is a way.  You can tell the system that instead of
printing on your terminal, you want the same information put in a file.
The way to do it is to add to the command line the character '>' and the
name of the file where you want the output to go.  Then you can say

     cat  file1  file2  >bigfile

and the job is done.  (As with 'cp' and 'mv', you're putting something
into 'bigfile', and anything that was already there is destroyed.)

This ability to 'capture' the output of a program is one of the most
useful aspects of the system.  Fortunately it's not limited to the 'cat'
program -- you can use it with _any_ program that prints on your
terminal.  We'll see some more uses for it in a moment.

Naturally, you can combine several files, not just two:

     cat  file1  file2  file3  ...  >bigfile

collects a whole bunch.

Question: is there any difference between

     cp  good  savegood

and

     cat  good  >savegood

Answer: for most purposes, no.  You might reasonably ask why there are
two programs in that case, since 'cat' is obviously all you need.  The
answer is that 'cp' will do some other things as well, which you can
investigate for yourself by reading the manual.  For now we'll stick to
simple usages.


File: ed.info,  Node: Adding Something to the End of a File,  Prev: Putting Two or More Files Together,  Up: CUT AND PASTE WITH UNIX COMMANDS

Adding Something to the End of a File
-------------------------------------

Sometimes you want to add one file to the end of another.  We have
enough building blocks now that you can do it; in fact before reading
further it would be valuable if you figured out how.  To be specific,
how would you use 'cp', 'mv' and/or 'cat' to add the file 'good1' to the
end of the file 'good'?

You could try

     cat  good  good1  >temp
     mv  temp  good

which is probably most direct.  You should also understand why

     cat  good  good1  >good

doesn't work.  (Don't practice with a good 'good'!)

The easy way is to use a variant of '>', called '>>'.  In fact, '>>' is
identical to '>' except that instead of clobbering the old file, it
simply tacks stuff on at the end.  Thus you could say

     cat  good1  >>good

and 'good1' is added to the end of 'good'.  (And if 'good' didn't exist,
this makes a copy of 'good1' called 'good'.)


File: ed.info,  Node: CUT AND PASTE WITH THE EDITOR,  Next: SUPPORTING TOOLS,  Prev: CUT AND PASTE WITH UNIX COMMANDS,  Up: Advanced Editing on UNIX

2.6 CUT AND PASTE WITH THE EDITOR
=================================

Now we move on to manipulating pieces of files -- individual lines or
groups of lines.  This is another area where new users seem unsure of
themselves.

* Menu:

* Filenames::
* Inserting One File into Another::
* Writing Out Part of a File::
* Moving Lines Around::
* Marks::
* Copying Lines::
* The Temporary Escape:: ''!''


File: ed.info,  Node: Filenames,  Next: Inserting One File into Another,  Prev: CUT AND PASTE WITH THE EDITOR,  Up: CUT AND PASTE WITH THE EDITOR

Filenames
---------

The first step is to ensure that you know the 'ed' commands for reading
and writing files.  Of course you can't go very far without knowing 'r'
and 'w'.  Equally useful, but less well known, is the 'edit' command
'e'.  Within ed, the command

     e  newfile

says 'I want to edit a new file called _newfile_, without leaving the
editor.'  The 'e' command discards whatever you're currently working on
and starts over on _newfile_.  It's exactly the same as if you had quit
with the 'q' command, then re-entered 'ed' with a new file name, except
that if you have a pattern remembered, then a command like // will still
work.

If you enter 'ed' with the command

     ed  file

'ed' remembers the name of the file, and any subsequent 'e', 'r' or 'w'
commands that don't contain a filename will refer to this remembered
file.  Thus

       ed file1
       ... (editing) ...
       w                            (writes back in file1)
       e file2                      (edit new file, without leaving editor)
       ... (editing on file2) ...
       w                            (writes back on file2)

(and so on) does a series of edits on various files without ever leaving
'ed' and without typing the name of any file more than once.  (As an
aside, if you examine the sequence of commands here, you can see why
many UNIX systems use 'e' as a synonym for 'ed'.)

You can find out the remembered file name at any time with the 'f'
command; just type 'f' without a file name.  You can also change the
name of the remembered file name with 'f'; a useful sequence is

     ed  precious
     f  junk
     ... (editing) ...

which gets a copy of a precious file, then uses 'f' to guarantee that a
careless 'w' command won't clobber the original.


File: ed.info,  Node: Inserting One File into Another,  Next: Writing Out Part of a File,  Prev: Filenames,  Up: CUT AND PASTE WITH THE EDITOR

Inserting One File into Another
-------------------------------

Suppose you have a file called 'memo', and you want the file called
'table' to be inserted just after the reference to Table 1.  That is, in
'memo' somewhere is a line that says

     Table 1 shows that ...

and the data contained in 'table' has to go there, probably so it will
be formatted properly by 'nroff' or 'troff'.  Now what?

This one is easy.  Edit 'memo', find 'Table 1', and add the file 'table'
right there:

     ed  memo
     /Table 1/
     Table 1 shows that ... _[response from ed]_
     .r  table

The critical line is the last one.  As we said earlier, the 'r' command
reads a file; here you asked for it to be read in right after line dot.
An 'r' command without any address adds lines at the end, so it is the
same as '$r'.


File: ed.info,  Node: Writing Out Part of a File,  Next: Moving Lines Around,  Prev: Inserting One File into Another,  Up: CUT AND PASTE WITH THE EDITOR

Writing Out Part of a File
--------------------------

The other side of the coin is writing out part of the document you're
editing.  For example, maybe you want to split out into a separate file
that table from the previous example, so it can be formatted and tested
separately.  Suppose that in the file being edited we have

     .TS
     ... _[lots of stuff]_
     .TE

which is the way a table is set up for the 'tbl' program.  To isolate
the table in a separate file called 'table', first find the start of the
table (the '.TS' line), then write out the interesting part:

     /^\.TS/
     .TS  _[ed prints the line it found]_
     .,/^\.TE/w table

and the job is done.  If you are confident, you can do it all at once
with

     /^\.TS/;/^\.TE/w table

The point is that the 'w' command can write out a group of lines,
instead of the whole file.  In fact, you can write out a single line if
you like; just give one line number instead of two.  For example, if you
have just typed a horribly complicated line and you know that it (or
something like it) is going to be needed later, then save it -- don't
re-type it.  In the editor, say

     a
     ... _lots of stuff_ ...
     ... _horrible line_ ...
     .
     .w  temp
     a
     ... _more stuff_ ...
     .
     .r temp
     a
     ... _more stuff_ ...
     .

This last example is worth studying, to be sure you appreciate what's
going on.


File: ed.info,  Node: Moving Lines Around,  Next: Marks,  Prev: Writing Out Part of a File,  Up: CUT AND PASTE WITH THE EDITOR

Moving Lines Around
-------------------

Suppose you want to move a paragraph from its present position in a
paper to the end.  How would you do it?  As a concrete example, suppose
each paragraph in the paper begins with the formatting command '.PP'.
Think about it and write down the details before reading on.

The brute force way (not necessarily bad) is to write the paragraph onto
a temporary file, delete it from its current position, then read in the
temporary file at the end.  Assuming that you are sitting on the '.PP'
command that begins the paragraph, this is the sequence of commands:

     .,/^\.PP/-w temp
     .,//-d
     $r temp

That is, from where you are now ('.')  until one line before the next
'.PP' ('/^\.PP/-') write onto 'temp'.  Then delete the same lines.
Finally, read 'temp' at the end.

As we said, that's the brute force way.  The easier way (often) is to
use the _move_ command 'm' that 'ed' provides -- it lets you do the
whole set of operations at one crack, without any temporary file.

The 'm' command is like many other 'ed' commands in that it takes up to
two line numbers in front that tell what lines are to be affected.  It
is also _followed_ by a line number that tells where the lines are to
go.  Thus

     line1, line2 m line3

says to move all the lines between 'line1' and 'line2' after 'line3'.
Naturally, any of 'line1' etc., can be patterns between slashes, $
signs, or other ways to specify lines.

Suppose again that you're sitting at the first line of the paragraph.
Then you can say

     .,/^\.PP/-m$

That's all.

As another example of a frequent operation, you can reverse the order of
two adjacent lines by moving the first one to after the second.  Suppose
that you are positioned at the first.  Then

     m+

does it.  It says to move line dot to after one line after line dot.  If
you are positioned on the second line,

     m--

does the interchange.

As you can see, the 'm' command is more succinct and direct than
writing, deleting and re-reading.  When is brute force better anyway?
This is a matter of personal taste -- do what you have most confidence
in.  The main difficulty with the 'm' command is that if you use
patterns to specify both the lines you are moving and the target, you
have to take care that you specify them properly, or you may well not
move the lines you thought you did.  The result of a botched 'm' command
can be a ghastly mess.  Doing the job a step at a time makes it easier
for you to verify at each step that you accomplished what you wanted to.
It's also a good idea to issue a 'w' command before doing anything
complicated; then if you goof, it's easy to back up to where you were.


File: ed.info,  Node: Marks,  Next: Copying Lines,  Prev: Moving Lines Around,  Up: CUT AND PASTE WITH THE EDITOR

Marks
-----

'ed' provides a facility for marking a line with a particular name so
you can later reference it by name regardless of its actual line number.
This can be handy for moving lines, and for keeping track of them as
they move.  The _mark_ command is 'k'; the command

     kx

marks the current line with the name 'x'.  If a line number precedes the
'k', that line is marked.  (The mark name must be a single lower case
letter.)  Now you can refer to the marked line with the address

     'x

Marks are most useful for moving things around.  Find the first line of
the block to be moved, and mark it with 'a.  Then find the last line and
mark it with 'b.  Now position yourself at the place where the stuff is
to go and say

     'a,'bm.

Bear in mind that only one line can have a particular mark name
associated with it at any given time.


File: ed.info,  Node: Copying Lines,  Next: The Temporary Escape,  Prev: Marks,  Up: CUT AND PASTE WITH THE EDITOR

Copying Lines
-------------

We mentioned earlier the idea of saving a line that was hard to type or
used often, so as to cut down on typing time.  Of course this could be
more than one line; then the saving is presumably even greater.

'ed' provides another command, called 't' (for 'transfer') for making a
copy of a group of one or more lines at any point.  This is often easier
than writing and reading.

The 't' command is identical to the 'm' command, except that instead of
moving lines it simply duplicates them at the place you named.  Thus

     1,$t$

duplicates the entire contents that you are editing.  A more common use
for 't' is for creating a series of lines that differ only slightly.
For example, you can say

       a
       ...... x ......   (long line)
       .
       t.                (make a copy)
       s/x/y/            (change it a bit)
       t.                (make third copy)
       s/y/z/            (change it a bit)

and so on.


File: ed.info,  Node: The Temporary Escape,  Prev: Copying Lines,  Up: CUT AND PASTE WITH THE EDITOR

The Temporary Escape '!'
------------------------

Sometimes it is convenient to be able to temporarily escape from the
editor to do some other UNIX command, perhaps one of the file copy or
move commands discussed in section 5, without leaving the editor.  The
'escape' command '!' provides a way to do this.

If you say

     !any UNIX command

your current editing state is suspended, and the UNIX command you asked
for is executed.  When the command finishes, 'ed' will signal you by
printing another '!'; at that point you can resume editing.

You can really do any UNIX command, including another 'ed'.  (This is
quite common, in fact.)  In this case, you can even do another '!'.


File: ed.info,  Node: SUPPORTING TOOLS,  Next: Acknowledgement,  Prev: CUT AND PASTE WITH THE EDITOR,  Up: Advanced Editing on UNIX

2.7 SUPPORTING TOOLS
====================

There are several tools and techniques that go along with the editor,
all of which are relatively easy once you know how 'ed' works, because
they are all based on the editor.  In this section we will give some
fairly cursory examples of these tools, more to indicate their existence
than to provide a complete tutorial.  More information on each can be
found in [3].

* Menu:

* Grep::
* Editing Scripts::
* Sed::


File: ed.info,  Node: Grep,  Next: Editing Scripts,  Prev: SUPPORTING TOOLS,  Up: SUPPORTING TOOLS

Grep
----

Sometimes you want to find all occurrences of some word or pattern in a
set of files, to edit them or perhaps just to verify their presence or
absence.  It may be possible to edit each file separately and look for
the pattern of interest, but if there are many files this can get very
tedious, and if the files are really big, it may be impossible because
of limits in 'ed'.

The program 'grep' was invented to get around these limitations.  The
search patterns that we have described in the paper are often called
'regular expressions', and 'grep' stands for

     g/re/p

That describes exactly what 'grep' does -- it prints every line in a set
of files that contains a particular pattern.  Thus

     grep  'thing'  file1  file2  file3  ...

finds 'thing' wherever it occurs in any of the files 'file1', 'file2',
etc.  'grep' also indicates the file in which the line was found, so you
can later edit it if you like.

The pattern represented by 'thing' can be any pattern you can use in the
editor, since 'grep' and 'ed' use exactly the same mechanism for pattern
searching.  It is wisest always to enclose the pattern in the single
quotes '...' if it contains any non-alphabetic characters, since many
such characters also mean something special to the UNIX command
interpreter (the 'shell').  If you don't quote them, the command
interpreter will try to interpret them before 'grep' gets a chance.

There is also a way to find lines that _don't_ contain a pattern:

     grep  -v  'thing'  file1  file2  ...

finds all lines that don't contains 'thing'.  The '-v' must occur in the
position shown.  Given 'grep' and 'grep -v', it is possible to do things
like selecting all lines that contain some combination of patterns.  For
example, to get all lines that contain 'x' but not 'y':

     grep  x  file ...  |  grep  -v  y

(The notation '|' is a 'pipe', which causes the output of the first
command to be used as input to the second command; see [2].)


File: ed.info,  Node: Editing Scripts,  Next: Sed,  Prev: Grep,  Up: SUPPORTING TOOLS

Editing Scripts
---------------

If a fairly complicated set of editing operations is to be done on a
whole set of files, the easiest thing to do is to make up a 'script',
i.e., a file that contains the operations you want to perform, then
apply this script to each file in turn.

For example, suppose you want to change every 'Unix' to 'UNIX' and every
'Gcos' to 'GCOS' in a large number of files.  Then put into the file
'script' the lines

     g/Unix/s//UNIX/g
     g/Gcos/s//GCOS/g
     w
     q

Now you can say

     ed file1 <script
     ed file2 <script
     ...

This causes 'ed' to take its commands from the prepared script.  Notice
that the whole job has to be planned in advance.

And of course by using the UNIX command interpreter, you can cycle
through a set of files automatically, with varying degrees of ease.


File: ed.info,  Node: Sed,  Prev: Editing Scripts,  Up: SUPPORTING TOOLS

Sed
---

'sed' ('stream editor') is a version of the editor with restricted
capabilities but which is capable of processing unlimited amounts of
input.  Basically 'sed' copies its input to its output, applying one or
more editing commands to each line of input.

As an example, suppose that we want to do the 'Unix' to 'UNIX' part of
the example given above, but without rewriting the files.  Then the
command

     sed  's/Unix/UNIX/g'  file1  file2  ...

applies the command 's/Unix/UNIX/g' to all lines from 'file1', 'file2',
etc., and copies all lines to the output.  The advantage of using 'sed'
in such a case is that it can be used with input too large for 'ed' to
handle.  All the output can be collected in one place, either in a file
or perhaps piped into another program.

If the editing transformation is so complicated that more than one
editing command is needed, commands can be supplied from a file, or on
the command line, with a slightly more complex syntax.  To take commands
from a file, for example,

     sed  -f  cmdfile  input-files ...

'sed' has further capabilities, including conditional testing and
branching, which we cannot go into here.


File: ed.info,  Node: Acknowledgement,  Next: References,  Prev: SUPPORTING TOOLS,  Up: Advanced Editing on UNIX

Acknowledgement
===============

I am grateful to Ted Dolotta for his careful reading and valuable
suggestions.


File: ed.info,  Node: References,  Prev: Acknowledgement,  Up: Advanced Editing on UNIX

References
==========

[1]Brian W. Kernighan, _A Tutorial Introduction to the UNIX Text
   Editor_, Bell Laboratories internal memorandum.
[2]Brian W. Kernighan, _UNIX For Beginners_, Bell Laboratories internal
   memorandum.
[3]Ken L. Thompson and Dennis M. Ritchie, _The UNIX Programmer's
   Manual_.  Bell Laboratories.


File: ed.info,  Node: Switches,  Next: Line Addressing,  Prev: Tutorial,  Up: Top

3 Command-Line Options for Invoking Ed
**************************************

     ed [OPTION...] [FILE]

Options:

'-f, --file=SCRIPT'
     Read editing commands from file SCRIPT instead of standard input.
     Implies '-s'.

'-G, --traditional'
     Enable backward compatibility with historical versions of 'ed'.

'-h, --help'
     Display help, then exit.

'-p, --prompt=STRING'
     Prompt for commands with STRING.  The prompt can be toggled on and
     off with the 'P' command.

'-r, --regexp-extended'
     Enable extended regular expression syntax.  By default, 'ed'
     interprets patterns using basic regular expression syntax.

'-s, --script'
     Suppress interactive diagnostics.  Use this option if 'ed''s
     standard input is from a script.

'-v, --verbose'
     Enable verbose error diagnostics.  Verbose mode can be toggled on
     and off with the 'H' command.

'-V, --version'
     Print version information, then exit.

If FILE is given, open it for editing.  If FILE is prefixed with '!'
(exclamation point), then execute the (string) FILE as shell command,
and read its standard output for editing (see 'sh(1)').  To open a file
whose name begins with a '!', prefix the name with '\' (backslash).


File: ed.info,  Node: Line Addressing,  Next: Regular Expressions,  Prev: Switches,  Up: Top

4 Addressing Lines in the Buffer
********************************

An "address" represents the number of a line in the buffer.  'Ed'
maintains a "current address" which is typically supplied to commands as
the default address when none is specified.  When a file is first read,
the current address is set to the last line of the file.  In general,
the current address is set to the last line affected by a command.

A line address is constructed from one of the bases in the list below,
optionally followed by a numeric offset.  The offset may include any
combination of digits, operators (i.e., '+', '-' and '^') and
whitespace.  Addresses are read from left to right, and their values are
computed relative to the current address.

One exception to the rule that addresses represent line numbers is the
address '0' (zero).  This means "before the first line," and is legal
wherever it makes sense.

An "address range" is two addresses separated by either a ',' (comma) or
';' (semicolon).  The value of the first address in a range cannot
exceed the value of the the second.  Each address in a comma-delimited
range is interpreted relative to the current address.  In a
semicolon-delimited range, the semicolon acts as an operator which sets
the current address to the address immediately preceding the semicolon.
Subsequent addresses are interpreted relative to the new current
address.

If only the first address in a range is given, then the second address
is set to the given address.  If only the second address in a
comma-delimited range is given, then the first address is set to 1.  If
only the second address in a semicolon-delimited range is given, then
the first address is set to the current address.

If an N-tuple of addresses is given where N > 2, then the corresponding
(two-address) range is set to the last two addresses after evaluating
each address of the N-tuple in sequence.  If only one address is
expected, then the last address is used.

The following address symbols are recognized.

'.'
     The current line (address) in the buffer.

'$'
     The last line in the buffer.

'N'
     The Nth, line in the buffer where N is a number in the range '0,$'.

'-'
'^'
     The previous line.  This is equivalent to '-1' and may be repeated
     with cumulative effect.

'-N'
'^N'
     The Nth previous line, where N is a non-negative number.

'+'
     The next line.  This is equivalent to '+1' and may be repeated with
     cumulative effect.

'+N'
'WHITESPACE N'
     The Nth next line, where N is a non-negative number.  Whitespace
     followed by a number N is interpreted as '+N'.

','
'%'
     The first through last lines in the buffer.  This is equivalent to
     the address range '1,$'.

';'
     The current through last lines in the buffer.  This is equivalent
     to the address range '.,$'.

'/RE/'
     The next line containing the regular expression RE.  The search
     wraps to the beginning of the buffer and continues down to the
     current line, if necessary.  '//' repeats the last search.

'?RE?'
     The previous line containing the regular expression RE.  The search
     wraps to the end of the buffer and continues up to the current
     line, if necessary.  '??' repeats the last search.

''LC'
     The line previously marked by a 'k' (mark) command, where LC is a
     lower case letter.


File: ed.info,  Node: Regular Expressions,  Next: Extended Expressions,  Prev: Line Addressing,  Up: Top

5 Basic Regular Expressions: Searching for Text
***********************************************

"Regular expressions" are patterns used in selecting text.  For example,
the 'ed' command:

     g/STRING/

prints all lines containing STRING.  Regular expressions are also used
by the 's' command for selecting old text to be replaced with new.

In addition to a specifying string literals, regular expressions can
represent classes of strings.  Strings thus represented are said to be
matched by the corresponding regular expression.  If it is possible for
a regular expression to match several strings in a line, then the
left-most longest match is the one selected.

The following symbols can be used in constructing "basic regular
expressions" (BREs):

'C'
     Any character C, except for '.', '*', '[', '^', '$' and '\',
     matches itself.

'\C'
     Any backslash-escaped character C, except for '{', '}', '(', ')',
     matches itself.  See also the discussion about 'GNU Regex' below.

'.'
     Matches any single character except _end-of-line_.

'[CHAR-CLASS]'
     Matches any single character in CHAR-CLASS except _end-of-line_.
     To include a ']' in CHAR-CLASS, it must be the first character.  A
     range of characters can be specified by separating the end
     characters of the range with a '-', e.g., 'a-z' specifies the lower
     case characters.  If '-' appears as the first or last character of
     CHAR-CLASS, then it matches itself.  All other characters in
     CHAR-CLASS match themselves.

     The following literal expressions can also be used in CHAR-CLASS to
     specify sets of characters:

          [:alnum:] [:cntrl:] [:lower:] [:space:]
          [:alpha:] [:digit:] [:print:] [:upper:]
          [:blank:] [:graph:] [:punct:] [:xdigit:]

     Patterns in CHAR-CLASS of the form:
          [.COL-ELM.]
          [=COL-ELM=]

     where COL-ELM is a "collating element" are interpreted according to
     'locale (5)'.  See 'regex (3)' for an explanation of these
     constructs.

'[^CHAR-CLASS]'
     Matches any single character, except _end-of-line_, not in
     CHAR-CLASS.  CHAR-CLASS is defined as above.

'^'
     If '^' is the first character of a regular expression, then it
     anchors the regular expression to the beginning of a line.
     Otherwise, it matches itself.

'$'
     If '$' is the last character of a regular expression, it anchors
     the regular expression to the end of a line.  Otherwise, it matches
     itself.

'\(RE\)'
     Defines a (possibly null) subexpression RE.  Subexpressions may be
     nested.  A subsequent backreference of the form \'N', where N is a
     number in the interval [1,9], expands to the text matched by the
     Nth subexpression.  For example, the regular expression '\(a.c\)\1'
     matches the string 'abcabc', but not 'abcadc'.  Subexpressions are
     ordered relative to their left delimiter.

'*'
     Matches the single character regular expression or subexpression
     immediately preceding it zero or more times.  If '*' (asterisk) is
     the first character of a regular expression or subexpression, then
     it matches itself.  Patterns constructed with the '*' operator can
     produce unexpected null matches.  For instance, the regular
     expression 'b*' matches the (null string at the) beginning of
     'abbb', as opposed to the substring 'bbb', since a null match is
     the only left-most match.

'\{N,M\}'
'\{N,\}'
'\{N\}'
     Matches the single character regular expression or subexpression
     immediately preceding it at least N and at most M times.  If M is
     omitted, then it matches at least N times.  If the comma is also
     omitted, then it matches exactly N times.

If 'ed' is linked against the GNU regular expression library, then the
following non-standard regular expression operators are available.

'\`'
'\''
     Unconditionally matches the beginning '\`' or ending '\'' of a
     line.

'\?'
     Optionally matches the single character regular expression or
     subexpression immediately preceding it.  For example, the regular
     expression 'a[bd]\?c' matches the strings 'abc', 'adc' and 'ac'.
     If '\?' occurs at the beginning of a regular expressions or
     subexpression, then it matches a literal '?'.

'\+'
     Matches the single character regular expression or subexpression
     immediately preceding it one or more times.  So the regular
     expression 'a+' is shorthand for 'aa*'.  If '\+' occurs at the
     beginning of a regular expression or subexpression, then it matches
     a literal '+'.

'\b'
     Matches the (null string at the) beginning or ending of a word.

'\B'
     Matches (a null string) inside a word.

'\<'
     Matches the (null string at the) beginning of a word.

'\>'
     Matches the (null string at the) end of a word.

'\w'
     Matches any character in a word.

'\W'
     Matches any character not in a word.

'\|'
     Logical _OR_ of regular expressions.  It matches if any one of
     several alternative expressions matches.  If more than one match is
     found, then the longest match is selected.  For example, the
     regular expression 'a\(xx\|yy\|zz\)b' matches each of the strings
     'axxb', 'ayyb' and 'azzb'.


File: ed.info,  Node: Extended Expressions,  Next: Command Reference,  Prev: Regular Expressions,  Up: Top

6 Extended Regular Expressions: Advanced Text Search
****************************************************

If 'ed' is invoked with either '-r' (GNU) or '-E' (BSD) option, then
patterns are interpreted according to "extended regular expression"
(ERE) syntax, which adds three new operators to BREs:

     ? + and |.

Of these, only the '|' (read _alternation_) operator has no BRE
equivalent.  It separates multiple patterns which are tested in sequence
until a match is found.  For example,

     g/STRINGA|STRINGB/

prints all lines containing either STRINGA or STRINGB.

EREs are constructed from the same symbols as BREs with the following
exceptions:

'C'
     Any character C, except for '.', '?', '*', '+', '[', '^', '$', '|'
     and '\', matches itself.

'\C'
     Any backslash-escaped character C, matches itself.  See also the
     discussion about 'GNU Regex' in *note Regular Expressions::.

'?'
     Equivalent to the BRE '\{0,1\}' -- see *note Regular Expressions::.

'+'
     Equivalent to the BRE '\{1,\}' -- see *note Regular Expressions::.

'|'
     Logical _OR_ of regular expressions.  It matches if any one of
     several alternative expressions matches.  If more than one match is
     found, then the longest match is selected.

'(RE)'
     Equivalent to the BRE '\(RE\)' -- see *note Regular Expressions::.

'{N,M}'
'{N,}'
'{N}'
     Equivalent to the BREs '\{N,M\}', '\{N,\}' and '\{N\}',
     respectively -- see *note Regular Expressions::.


File: ed.info,  Node: Command Reference,  Next: Environment,  Prev: Extended Expressions,  Up: Top

7 'Ed' Command Reference
************************

All 'ed' commands are single characters, though some require additonal
parameters.  If a command's parameters extend over several lines, then
each line except for the last must be terminated with a backslash ('\').

In general, at most one command is allowed per line.  However, most
commands accept a print suffix, which is any of 'p' (print), 'l' (list),
or 'n' (enumerate), to print the last line affected by the command.

An interrupt (typically <C-c>) has the effect of aborting the current
command and returning the editor to command mode.

'ed' recognizes the following commands.  The commands are shown together
with the default address or address range supplied if none is specified
(in parenthesis).

'(.)a'
     Appends text to the buffer after the addressed line, which may be
     the address '0' (zero).  Text is entered in input mode.  The
     current address is set to last line entered.

'(.,.)c'
     Changes lines in the buffer.  The addressed lines are deleted from
     the buffer, and text is appended in their place.  Text is entered
     in input mode.  The current address is set to last line entered.

'(.,.)d'
     Deletes the addressed lines from the buffer.  If there is a line
     after the deleted range, then the current address is set to this
     line.  Otherwise the current address is set to the line before the
     deleted range.

'e FILE'
     Edits FILE, and sets the default filename.  If FILE is not
     specified, then the default filename is used.  Any lines in the
     buffer are deleted before the new file is read.  The current
     address is set to the last line read.

'e !COMMAND'
     Edits the standard output of '!COMMAND', (see the '!' command
     below).  The default filename is unchanged.  Any lines in the
     buffer are deleted before the output of COMMAND is read.  The
     current address is set to the last line read.

'E FILE'
     Edits FILE unconditionally.  This is similar to the 'e' command,
     except that unwritten changes are discarded without warning.  The
     current address is set to the last line read.

'f FILE'
     Sets the default filename to FILE.  If FILE is not specified, then
     the default unescaped filename is printed.

'(1,$)g/RE/COMMAND-LIST'
     Applies COMMAND-LIST to each of the addressed lines matching a
     regular expression RE.  The current address is set to the line
     currently matched before COMMAND-LIST is executed.  At the end of
     the 'g' command, the current address is set to the last line
     affected by COMMAND-LIST.

     Each command in COMMAND-LIST must be on a separate line, and every
     line except for the last must be terminated by a '\' (backslash).
     Any commands are allowed, except for 'g', 'G', 'v', and 'V'.  By
     default, a null command in COMMAND-LIST is equivalent to a 'p'
     command.

'(1,$)G/RE/'
     Interactively edits the addressed lines matching a regular
     expression RE.  For each matching line, the line is printed, the
     current address is set, and the user is prompted to enter a
     COMMAND-LIST.  At the end of the 'G' command, the current address
     is set to the last line affected by (the last) COMMAND-LIST.

     The format of COMMAND-LIST is the same as that of the 'g' command.
     A single '&' repeats the last non-null command list.

'H'
     Toggles the printing of error explanations.  By default,
     explanations are not printed.  It is recommended that ed scripts
     begin with this command to aid in debugging.

'h'
     Prints an explanation of the last error.

'(.)i'
     Inserts text in the buffer before the current line.  Text is
     entered in input mode.  The current address is set to the last line
     entered.

'(.,.+1)j'
     Joins the addressed lines.  The addressed lines are deleted from
     the buffer and replaced by a single line containing their joined
     text.  The current address is set to the resultant line.

'(.)kLC'
     Marks a line with a lower case letter LC.  The line can then be
     addressed as ''LC' (i.e., a single quote followed by LC) in
     subsequent commands.  The mark is not cleared until the line is
     deleted or otherwise modified.

'(.,.)l'
     Prints the addressed lines unambiguously.  If invoked from a
     terminal, 'ed' pauses at the end of each page until a <RET> is
     entered.  The current address is set to the last line printed.

'(.,.)m(.)'
     Moves lines in the buffer.  The addressed lines are moved to after
     the right-hand destination address, which may be the address '0'
     (zero).  The current address is set to the last line moved.

'(.,.)n'
     Prints the addressed lines along with their line numbers.  The
     current address is set to the last line printed.

'(.,.)p'
     Prints the addressed lines.  The current address is set to the last
     line printed.

'P'
     Toggles the command prompt on and off.  Unless a prompt is
     specified with command-line option '-p PROMPT', the command prompt
     is by default turned off.

'q'
     Quits 'ed'.

'Q'
     Quits 'ed' unconditionally.  This is similar to the 'q' command,
     except that unwritten changes are discarded without warning.

'($)r FILE'
     Reads FILE to after the addressed line.  If FILE is not specified,
     then the default filename is used.  If there is no default filename
     prior to the command, then the default filename is set to FILE.
     Otherwise, the default filename is unchanged.  The current address
     is set to the last line read.

'($)r !COMMAND'
     Reads to after the addressed line the standard output of
     '!COMMAND', (see the '!' command below).  The default filename is
     unchanged.  The current address is set to the last line read.

'(.,.)s/RE/REPLACEMENT/'
'(.,.)s/RE/REPLACEMENT/g'
'(.,.)s/RE/REPLACEMENT/n'
     Replaces text in the addressed lines matching a regular expression
     RE with REPLACEMENT.  By default, only the first match in each line
     is replaced.  If the 'g' (global) suffix is given, then every match
     to be replaced.  The 'n' suffix, where N is a postive number,
     causes only the Nth match to be replaced.  It is an error if no
     substitutions are performed on any of the addressed lines.  The
     current address is set the last line affected.

     RE and REPLACEMENT may be delimited by any character other than
     <SPC> and <RET> (see the 's' command below).  If one or two of the
     last delimiters is omitted, then the last line affected is printed
     as though the print suffix 'p' were specified.

     An unescaped '&' in REPLACEMENT is replaced by the currently
     matched text.  The character sequence 'M' where M is a number in
     the range [1,9], is replaced by the Mth backreference expression of
     the matched text.  If REPLACEMENT consists of a single '%', then
     REPLACEMENT from the last substitution is used.  An _end-of-line_
     character can be embedded in REPLACEMENT if they are escaped with a
     backslash ('\').

'(.,.)s'
     Repeats the last substitution.  This form of the 's' command
     accepts a count suffix N, or any combination of the characters 'r',
     'g', and 'p'.  If a count suffix N is given, then only the Nth
     match is replaced.  The 'r' suffix causes the regular expression of
     the last search to be used instead of the that of the last
     substitution.  The 'g' suffix toggles the global suffix of the last
     substitution.  The 'p' suffix toggles the print suffix of the last
     substitution The current address is set to the last line affected.

'(.,.)t(.)'
     Copies (i.e., transfers) the addressed lines to after the
     right-hand destination address, which may be the address '0'
     (zero).  The current address is set to the last line copied.

'u'
     Undoes the last command and restores the current address to what it
     was before the command.  The global commands 'g', 'G', 'v', and 'V'
     are treated as a single command by undo.  'u' is its own inverse.

'(1,$)v/RE/COMMAND-LIST'
     Applies COMMAND-LIST to each of the addressed lines not matching a
     regular expression RE.  This is similar to the 'g' command.

'(1,$)V/RE/'
     Interactively edits the addressed lines not matching a regular
     expression RE.  This is similar to the 'G' command.

'(1,$)w FILE'
     Writes the addressed lines to FILE.  Any previous contents of FILE
     is lost without warning.  If there is no default filename, then the
     default filename is set to FILE, otherwise it is unchanged.  If no
     filename is specified, then the default filename is used.  The
     current address is unchanged.

'(1,$)wq FILE'
     Writes the addressed lines to FILE, and then executes a 'q'
     command.

'(1,$)w !COMMAND'
     Writes the addressed lines to the standard input of '!COMMAND',
     (see the '!' command below).  The default filename and current
     address are unchanged.

'(1,$)W FILE'
     Appends the addressed lines to the end of FILE.  This is similar to
     the 'w' command, expect that the previous contents of file is not
     clobbered.  The current address is unchanged.

'(.+1)z N'
     Scrolls N lines at a time starting at addressed line.  If N is not
     specified, then the current window size is used.  The current
     address is set to the last line printed.

'! COMMAND'
     Executes COMMAND via 'sh(1)'.  If the first character of COMMAND is
     '!', then it is replaced by text of the previous '!COMMAND'.  'ed'
     does not process COMMAND for backslash ('\') escapes.  However, an
     unescaped '%' is replaced by the default filename.  When the shell
     returns from execution, a '!' is printed to the standard output.
     The current line is unchanged.

'(.,.)#'
     Begins a comment; the rest of the line, up to _end-of-line_, is
     ignored.  If a line address followed by a semicolon is given, then
     the current address is set to that address.  Otherwise, the current
     address is unchanged.

'($)='
     Prints the line number of the addressed line.

'(.+1) <RET>'
     Prints the addressed line, and sets the current address to that
     line.


File: ed.info,  Node: Environment,  Next: Limitations,  Prev: Command Reference,  Up: Top

8 Environment Variables Affecting Ed
************************************

'Ed' recognizes the following environment variables:

'COLUMNS'
     Screen width is initialized to value of 'COLUMNS'

'ED'
     If so configured, the 'ed' argument list is initialized with the
     value of the 'ED' environment variable.  This option presents a
     security risk since 'ED' can be set to execute arbitrary commands
     whenever 'ed' is run.

'HOME'
     User's home directory.

'LINES'
     Screen height.

'POSIXLY_CORRECT'
     If defined, do

'TMP'


File: ed.info,  Node: Limitations,  Next: Error Handling,  Prev: Environment,  Up: Top

9 Limits of 'Ed'
****************

The buffer files are kept in '/tmp/ed.*'.  If the terminal hangs up,
'ed' attempts to write the buffer to file 'ed.hup'.

'ed' processes FILE arguments for backslash escapes, i.e., in a
filename, any characters preceded by a '\' (backslash) are interpreted
literally.

If a text (non-binary) file is not terminated by an _end-of-line_
character, then 'ed' appends one on reading/writing it.  In the case of
a binary file, 'ed' does not append an _end-of-line_ on reading/writing.

Per line overhead: 4 'int's.


File: ed.info,  Node: Error Handling,  Prev: Limitations,  Up: Top

10 Error Handling and Exit Status
*********************************

When an error occurs, if 'ed''s input is from a regular file or here
document, then it exits, otherwise it prints a '?' and returns to
command mode.  An explanation of the last error can be printed with the
'h' (help) command.

If the 'u' (undo) command occurs in a global command list, then the
command list is executed only once.

Attempting to quit 'ed' or edit another file before writing a modified
buffer results in an error.  If the command is entered a second time, it
succeeds, but any changes to the buffer are lost.

'ed' exits with 0 if no errors occurred; otherwise >0.



Tag Table:
Node: Top435
Node: Overview1426
Node: Tutorial3687
Node: A Tutorial Introduction to the UNIX Text Editor4473
Node: Introduction6396
Node: Disclaimer7291
Node: Getting Started8188
Node: Creating Text8636
Node: Error Messages11599
Node: Writing to a file11991
Node: Leaving ed13456
Ref: Leaving ed-Footnote-114053
Node: Exercise 114210
Node: Reading text from a file14680
Node: Inserting text from a file16184
Node: Exercise 217179
Node: Printing the buffer17835
Node: Exercise 319840
Node: The current line20280
Node: Deleting lines23066
Node: Exercise 423913
Node: Modifying text24908
Node: Exercise 527797
Node: Context searching28713
Node: Exercise 632254
Node: Change and Insert33773
Node: Exercise 735401
Node: Moving text around36248
Node: The global commands37373
Node: Special Characters38659
Node: Summary42680
Node: Advanced Editing on UNIX45740
Node: INTRODUCTION46840
Node: SPECIAL CHARACTERS48336
Node: The List Command49354
Node: The Substitute Command51030
Node: The Undo Command52791
Node: The Metacharacter53238
Node: The Backslash55777
Node: The Dollar Sign58489
Node: The Circumflex59773
Node: The Star60620
Node: The Brackets64282
Node: The Ampersand66301
Node: Substituting Newlines67772
Node: Joining Lines69135
Node: Rearranging a Line69896
Node: LINE ADDRESSING71827
Node: Address Arithmetic73024
Node: Repeated Searches74614
Node: Default Addresses75822
Node: Semicolon79867
Node: Interrupting the Editor82525
Node: GLOBAL COMMANDS83482
Node: The Global Command List83894
Node: Multi-line Global Commands86488
Node: CUT AND PASTE WITH UNIX COMMANDS88066
Node: Changing the Name of a File89118
Node: Making a Copy of a File89914
Node: Removing a File91342
Node: Putting Two or More Files Together91701
Node: Adding Something to the End of a File94081
Node: CUT AND PASTE WITH THE EDITOR95159
Node: Filenames95707
Node: Inserting One File into Another97618
Node: Writing Out Part of a File98576
Node: Moving Lines Around100139
Node: Marks102953
Node: Copying Lines103922
Node: The Temporary Escape105006
Node: SUPPORTING TOOLS105797
Node: Grep106390
Node: Editing Scripts108463
Node: Sed109383
Node: Acknowledgement110629
Node: References110858
Node: Switches111273
Node: Line Addressing112584
Node: Regular Expressions116025
Node: Extended Expressions121364
Node: Command Reference122945
Node: Environment133242
Node: Limitations133884
Node: Error Handling134520

End Tag Table
